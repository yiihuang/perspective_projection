<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hemispherical Perspective with Postel Projection</title>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #f0f2f5;
            color: #333;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
            flex-wrap: wrap;
        }
        .view {
            flex: 1;
            min-width: 300px;
            min-height: 300px;
            position: relative;
            border: 1px solid #d1d5db;
        }
        #view3D {
            background-color: #ffffff;
            cursor: move;
        }
        #view2D {
            background-color: #f9fafb;
            cursor: ns-resize;
        }
        canvas {
            display: block;
        }
        h1 {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 8px;
            font-size: 1em;
            font-weight: 500;
            text-align: center;
            z-index: 10;
            max-width: 90%;
            box-sizing: border-box;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-container label {
            font-size: 0.9em;
            width: 120px;
        }
        .slider-container input[type="range"] {
            width: 200px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="container">
        <div id="view3D" class="view">
            <h1>3D Scene with Hemispherical Image Surface</h1>
        </div>
        <div id="view2D" class="view">
            <h1>Flattened Hemisphere using Postel Projection</h1>
        </div>
    </div>

    <div id="controls">
        <div class="slider-container">
            <label for="viewpointY">Viewpoint Y</label>
            <input type="range" id="viewpointY" min="-10" max="10" value="2" step="0.1">
        </div>
        <div class="slider-container">
            <label for="viewpointZ">Viewpoint Z</label>
            <input type="range" id="viewpointZ" min="3" max="20" value="8" step="0.1">
        </div>
        <div class="slider-container">
            <label for="hemisphereRadius">Hemisphere Radius</label>
            <input type="range" id="hemisphereRadius" min="3" max="12" value="6" step="0.1">
        </div>
        <div class="slider-container">
            <label for="zoom3D">3D Zoom</label>
            <input type="range" id="zoom3D" min="10" max="40" value="16.5" step="0.1">
        </div>
        <div class="slider-container">
            <label for="cubeRotX">Cube Rot X</label>
            <input type="range" id="cubeRotX" min="-180" max="180" value="0" step="1">
        </div>
        <div class="slider-container">
            <label for="cubeRotY">Cube Rot Y</label>
            <input type="range" id="cubeRotY" min="-180" max="180" value="0" step="1">
        </div>
        <div class="slider-container">
            <label for="cubeRotZ">Cube Rot Z</label>
            <input type="range" id="cubeRotZ" min="-180" max="180" value="0" step="1">
        </div>
    </div>

    <script>
        // Core Scene Components
        let scene3D, camera3D, renderer3D;
        let scene2D, camera2D, renderer2D;
        let cube, viewpointSphere, hemisphere, projectionLinesGroup, projectedCubeLines;
        let projectedViewpointMarker, vanishingPointsGroup;
        
        // Parameters
        const CUBE_SIZE = 4;
        let viewpointPosition = new THREE.Vector3(0, 2, 8);
        let hemisphereCenter = new THREE.Vector3(0, 2, 8);
        let hemisphereRadius = 6;
        
        // Local rotation tracking
        let cubeLocalRotation = { x: 0, y: 0, z: 0 };

        // Mouse Interaction
        let isCubeDragging = false;
        let isSceneDragging = false;
        let isZooming2D = false;
        let previousMousePosition = { x: 0, y: 0 };
        let zoomLevel2D = 25;

        function init() {
            // Setup 3D View
            const view3D = document.getElementById('view3D');
            scene3D = new THREE.Scene();
            scene3D.background = new THREE.Color(0xffffff);

            camera3D = new THREE.PerspectiveCamera(75, view3D.clientWidth / view3D.clientHeight, 0.1, 1000);
            camera3D.position.set(8, 8, 12);
            camera3D.lookAt(new THREE.Vector3(0,0,0));

            renderer3D = new THREE.WebGLRenderer({ antialias: true });
            renderer3D.setSize(view3D.clientWidth, view3D.clientHeight);
            view3D.appendChild(renderer3D.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene3D.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene3D.add(directionalLight);

            // Setup 2D View
            const view2D = document.getElementById('view2D');
            scene2D = new THREE.Scene();
            scene2D.background = new THREE.Color(0xf9fafb);

            camera2D = new THREE.OrthographicCamera(0, 0, 0, 0, 1, 1000);
            camera2D.position.z = 5;

            renderer2D = new THREE.WebGLRenderer({ antialias: true });
            renderer2D.setSize(view2D.clientWidth, view2D.clientHeight);
            view2D.appendChild(renderer2D.domElement);

            createSceneObjects();
            update2DCamera();
            setupEventListeners();
            animate();
        }

        function createSceneObjects() {
            // Cube
            const cubeGeometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x00aaff, opacity: 0.75, transparent: true });
            cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.z = -5;
            scene3D.add(cube);
            
            const edges = new THREE.EdgesGeometry(cubeGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x004466 });
            const cubeEdges = new THREE.LineSegments(edges, lineMaterial);
            cube.add(cubeEdges);

            // Viewpoint Sphere
            const viewpointGeometry = new THREE.SphereGeometry(0.2, 32, 32);
            const viewpointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            viewpointSphere = new THREE.Mesh(viewpointGeometry, viewpointMaterial);
            scene3D.add(viewpointSphere);

            // Hemisphere
            const hemisphereGeometry = new THREE.SphereGeometry(hemisphereRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const hemisphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x0000ff, 
                transparent: true, 
                opacity: 0.15, 
                side: THREE.DoubleSide
            });
            hemisphere = new THREE.Mesh(hemisphereGeometry, hemisphereMaterial);
            hemisphere.position.copy(hemisphereCenter);
            // Flip hemisphere along z-axis so dome extends in +Z direction (away from cube)
            hemisphere.rotation.x = -Math.PI / 2;
            scene3D.add(hemisphere);
            
            const hemisphereWireframe = new THREE.WireframeGeometry(hemisphereGeometry);
            const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.3, transparent: true });
            const hemisphereWire = new THREE.LineSegments(hemisphereWireframe, wireframeMaterial);
            hemisphere.add(hemisphereWire);

            const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xdddddd);
            gridHelper.position.y = -5;
            scene3D.add(gridHelper);

            projectionLinesGroup = new THREE.Group();
            scene3D.add(projectionLinesGroup);
            
            projectedCubeLines = new THREE.Group();
            scene2D.add(projectedCubeLines);

            const pvRingGeom = new THREE.RingGeometry(0.15, 0.2, 24);
            const pvRingMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            projectedViewpointMarker = new THREE.Mesh(pvRingGeom, pvRingMat);
            scene2D.add(projectedViewpointMarker);

            // Vanishing points group
            vanishingPointsGroup = new THREE.Group();
            scene2D.add(vanishingPointsGroup);

            // Circle boundary will be created dynamically in updateProjection()

            updateProjection();
        }

        // Function to find intersection of ray with hemisphere
        function intersectRayWithHemisphere(rayOrigin, rayDirection) {
            const oc = rayOrigin.clone().sub(hemisphereCenter);
            const a = rayDirection.dot(rayDirection);
            const b = 2.0 * oc.dot(rayDirection);
            const c = oc.dot(oc) - hemisphereRadius * hemisphereRadius;
            
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) return null;
            
            const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
            const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);
            
            for (let t of [t1, t2]) {
                if (t > 0.001) {
                    const point = rayOrigin.clone().add(rayDirection.clone().multiplyScalar(t));
                    // Dome now extends in +Z direction (away from cube), so check z <= center.z
                    if (point.z <= hemisphereCenter.z) {
                        return point;
                    }
                }
            }
            return null;
        }

        // Function to find circle passing through three points and create arc
        function createCircularArc(p1, p2, p3, material) {
            // Calculate circle center and radius from three points
            const ax = p1.x, ay = p1.y;
            const bx = p2.x, by = p2.y; 
            const cx = p3.x, cy = p3.y;
            
            const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
            if (Math.abs(d) < 0.0001) {
                // Points are collinear, draw straight line
                return new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(p1.x, p1.y, 0),
                    new THREE.Vector3(p2.x, p2.y, 0)
                ]), material);
            }
            
            const ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d;
            const uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d;
            
            const centerX = ux;
            const centerY = uy;
            const radius = Math.sqrt((ax - centerX) * (ax - centerX) + (ay - centerY) * (ay - centerY));
            
            // Calculate angles for the arc from center to p1 and p2
            const angle1 = Math.atan2(p1.y - centerY, p1.x - centerX);
            const angle2 = Math.atan2(p2.y - centerY, p2.x - centerX);
            
            // Create arc geometry
            const segments = 32;
            const points = [];
            
            let startAngle = angle1;
            let endAngle = angle2;
            
            // Ensure we take the shorter arc
            let angleDiff = endAngle - startAngle;
            if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            
            endAngle = startAngle + angleDiff;
            
            for (let i = 0; i <= segments; i++) {
                const angle = startAngle + (endAngle - startAngle) * i / segments;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                points.push(new THREE.Vector3(x, y, 0));
            }
            
            return new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), material);
        }

        // Correct Postel projection
        function postelProjection(point3D) {
            // Convert to hemisphere-centered coordinates
            const relativePoint = point3D.clone().sub(hemisphereCenter);
            const x = relativePoint.x;
            const y = relativePoint.y;
            const z = relativePoint.z;
            
            // For our hemisphere setup, the "zenith" direction is -Z (towards cube)
            // Calculate angle α between point P and zenith z0
            // cos(α) = (OP · Oz0) / (|OP| * |Oz0|)
            // OP = (x,y,z), Oz0 = (0,0,-R) for dome extending in -Z
            const cosAlpha = -z / hemisphereRadius;  // Since (x,y,z)·(0,0,-R) = -z*R, and |OP|=R, |Oz0|=R
            const alpha = Math.acos(Math.max(-1, Math.min(1, cosAlpha)));
            
            // Arc length from zenith to point P  
            const arcLength = alpha * hemisphereRadius;
            
            // Azimuthal angle in XY plane
            const theta = Math.atan2(y, x);
            
            // Postel projection: use arc length directly as radius
            // Maximum radius = (π/2) * R when α = π/2 (hemisphere base)
            const x2D = arcLength * Math.cos(theta);
            const y2D = arcLength * Math.sin(theta);
            
            return new THREE.Vector2(x2D, y2D);
        }
        
        function updateProjection() {
            // Dynamically attach hemisphere center to viewpoint
            hemisphereCenter.copy(viewpointPosition);
            
            viewpointSphere.position.copy(viewpointPosition);
            hemisphere.position.copy(hemisphereCenter);
            // No scaling needed - geometry is already created with correct radius

            // Update 2D circle boundary to match current hemisphere radius
            // Remove old boundary
            if (window.circleBoundary) {
                scene2D.remove(window.circleBoundary);
                window.circleBoundary.geometry.dispose();
                window.circleBoundary.material.dispose();
            }
            
            // Create new boundary with radius π*R/2
            const postelBoundaryRadius = (Math.PI / 2) * hemisphereRadius;
            const circleGeometry = new THREE.RingGeometry(postelBoundaryRadius - 0.05, postelBoundaryRadius, 64);
            const circleMaterial = new THREE.MeshBasicMaterial({ color: 0x6667ab, side: THREE.DoubleSide });
            window.circleBoundary = new THREE.Mesh(circleGeometry, circleMaterial);
            scene2D.add(window.circleBoundary);

            const viewpointDir = hemisphereCenter.clone().sub(viewpointPosition).normalize();
            const viewpointOnHemisphere = intersectRayWithHemisphere(viewpointPosition, viewpointDir);
            if (viewpointOnHemisphere) {
                const projected2D = postelProjection(viewpointOnHemisphere);
                projectedViewpointMarker.position.set(projected2D.x, projected2D.y, 0.1);
            }

            projectionLinesGroup.children.forEach(c => c.geometry.dispose());
            projectionLinesGroup.remove(...projectionLinesGroup.children);
            projectedCubeLines.children.forEach(c => c.geometry.dispose());
            projectedCubeLines.remove(...projectedCubeLines.children);
            vanishingPointsGroup.children.forEach(c => { c.geometry.dispose(); c.material.dispose(); });
            vanishingPointsGroup.remove(...vanishingPointsGroup.children);
            
            cube.updateMatrixWorld();

            const halfSize = CUBE_SIZE / 2;
            const localVertices = [
                new THREE.Vector3(-halfSize, -halfSize, -halfSize), new THREE.Vector3( halfSize, -halfSize, -halfSize),
                new THREE.Vector3( halfSize,  halfSize, -halfSize), new THREE.Vector3(-halfSize,  halfSize, -halfSize),
                new THREE.Vector3(-halfSize, -halfSize,  halfSize), new THREE.Vector3( halfSize, -halfSize,  halfSize),
                new THREE.Vector3( halfSize,  halfSize,  halfSize), new THREE.Vector3(-halfSize,  halfSize,  halfSize)
            ];
            
            const worldVertices = localVertices.map(v => v.clone().applyMatrix4(cube.matrixWorld));
            const projectedVertices = [];

            worldVertices.forEach(worldVertex => {
                const rayDirection = worldVertex.clone().sub(viewpointPosition).normalize();
                
                const lineMat = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 });
                const extendedPoint = viewpointPosition.clone().add(rayDirection.clone().multiplyScalar(30));
                projectionLinesGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([viewpointPosition, extendedPoint]), lineMat));
                
                const hemisphereIntersection = intersectRayWithHemisphere(viewpointPosition, rayDirection);
                if (hemisphereIntersection) {
                    const hemisphereLineMat = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.6 });
                    projectionLinesGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([viewpointPosition, hemisphereIntersection]), hemisphereLineMat));
                    
                    const projected2D = postelProjection(hemisphereIntersection);
                    projectedVertices.push(projected2D);
                } else {
                    projectedVertices.push(new THREE.Vector2(Infinity, Infinity));
                }
            });

            // Calculate and draw vanishing points for hemispherical perspective
            // Get the three main direction vectors of the cube (parallel to cube edges)
            const dirX = new THREE.Vector3().subVectors(worldVertices[1], worldVertices[0]); // X-direction
            const dirY = new THREE.Vector3().subVectors(worldVertices[3], worldVertices[0]); // Y-direction  
            const dirZ = new THREE.Vector3().subVectors(worldVertices[4], worldVertices[0]); // Z-direction

            const vanishingPointData = [
                { dir: dirX.normalize(), color: 0xff4136 }, // Red for X
                { dir: dirY.normalize(), color: 0x2ecc40 }, // Green for Y
                { dir: dirZ.normalize(), color: 0x0074d9 }  // Blue for Z
            ];

            // Store vanishing points for arc generation
            const vanishingPoints = [];

            vanishingPointData.forEach(vpData => {
                // Check both positive and negative directions for each cube edge direction
                const directions = [vpData.dir, vpData.dir.clone().negate()];
                
                directions.forEach((direction, index) => {
                    // Create ray from viewpoint in direction parallel to cube edge
                    const hemisphereIntersection = intersectRayWithHemisphere(viewpointPosition, direction);
                    
                    if (hemisphereIntersection) {
                        // Project intersection to 2D using Postel projection
                        const projected2D = postelProjection(hemisphereIntersection);
                        
                        if (isFinite(projected2D.x) && isFinite(projected2D.y)) {
                            // Store vanishing point for arc generation
                            vanishingPoints.push(projected2D);
                            
                            // Create vanishing point marker in 2D
                            const vpGeom = new THREE.CircleGeometry(0.15, 16);
                            const vpMat = new THREE.MeshBasicMaterial({ 
                                color: vpData.color,
                                opacity: index === 0 ? 1.0 : 0.7, // Slightly transparent for negative direction
                                transparent: index === 1
                            });
                            const vpMesh = new THREE.Mesh(vpGeom, vpMat);
                            vpMesh.position.set(projected2D.x, projected2D.y, 0.1);
                            vanishingPointsGroup.add(vpMesh);
                        } else {
                            vanishingPoints.push(null);
                        }
                    } else {
                        vanishingPoints.push(null);
                    }
                });
            });

            // Function to determine which vanishing point to use for an edge
            function getVanishingPointForEdge(v1Index, v2Index) {
                const boundaryRadius = (Math.PI / 2) * hemisphereRadius;
                
                // Define cube edges and their corresponding axis directions
                const edgeDirections = {
                    // Bottom face edges
                    '0,1': 0, '1,0': 0,  // X-direction (red)
                    '1,2': 1, '2,1': 1,  // Y-direction (green)
                    '2,3': 0, '3,2': 0,  // X-direction (red)
                    '3,0': 1, '0,3': 1,  // Y-direction (green)
                    // Top face edges
                    '4,5': 0, '5,4': 0,  // X-direction (red)
                    '5,6': 1, '6,5': 1,  // Y-direction (green)  
                    '6,7': 0, '7,6': 0,  // X-direction (red)
                    '7,4': 1, '4,7': 1,  // Y-direction (green)
                    // Vertical edges
                    '0,4': 2, '4,0': 2,  // Z-direction (blue)
                    '1,5': 2, '5,1': 2,  // Z-direction (blue)
                    '2,6': 2, '6,2': 2,  // Z-direction (blue)
                    '3,7': 2, '7,3': 2   // Z-direction (blue)
                };
                
                const key = `${v1Index},${v2Index}`;
                let axisIndex = edgeDirections[key];
                if (axisIndex === undefined) return { vp: null, axisIndex: null };
                
                // Check both positive and negative directions for this axis
                const posVP = vanishingPoints[axisIndex * 2];     // positive direction
                const negVP = vanishingPoints[axisIndex * 2 + 1]; // negative direction
                
                // Choose the vanishing point that's inside the boundary circle
                if (posVP && (posVP.x * posVP.x + posVP.y * posVP.y) <= boundaryRadius * boundaryRadius) {
                    return { vp: posVP, axisIndex: axisIndex };
                }
                if (negVP && (negVP.x * negVP.x + negVP.y * negVP.y) <= boundaryRadius * boundaryRadius) {
                    return { vp: negVP, axisIndex: axisIndex };
                }
                
                return { vp: null, axisIndex: axisIndex };
            }

            // Function to get lighter color for guide lines
            function getLighterColor(axisIndex) {
                const colors = [
                    0xffaaaa, // Light red for X-axis
                    0xaaffaa, // Light green for Y-axis  
                    0xaaaaff  // Light blue for Z-axis
                ];
                return colors[axisIndex];
            }

            // Draw projected cube edges as circular arcs
            const edges = [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ];
            const projectedLineMaterial = new THREE.LineBasicMaterial({ color: 0x0077cc, linewidth: 2 });
            for (let i = 0; i < edges.length; i += 2) {
                const v1Index = edges[i];
                const v2Index = edges[i+1];
                const p1 = projectedVertices[v1Index];
                const p2 = projectedVertices[v2Index];
                
                if (p1 && p2 && isFinite(p1.x) && isFinite(p1.y) && isFinite(p2.x) && isFinite(p2.y)) {
                    const vpResult = getVanishingPointForEdge(v1Index, v2Index);
                    
                    if (vpResult.vp) {
                        // Draw circular arc through p1, p2, and vanishing point
                        const arc = createCircularArc(p1, p2, vpResult.vp, projectedLineMaterial);
                        projectedCubeLines.add(arc);
                        
                        // Draw guide lines from edge endpoints to vanishing point
                        const guideColor = getLighterColor(vpResult.axisIndex);
                        const guideMaterial = new THREE.LineBasicMaterial({ 
                            color: guideColor, 
                            opacity: 0.4, 
                            transparent: true,
                            linewidth: 1
                        });
                        
                        // Create extended arcs from each endpoint to vanishing point
                        const guide1 = createCircularArc(p1, vpResult.vp, p2, guideMaterial);
                        const guide2 = createCircularArc(p2, vpResult.vp, p1, guideMaterial);
                        
                        projectedCubeLines.add(guide1);
                        projectedCubeLines.add(guide2);
                        
                    } else {
                        // Fallback to straight line if no suitable vanishing point
                        const line2D = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(p1.x, p1.y, 0),
                            new THREE.Vector3(p2.x, p2.y, 0)
                        ]), projectedLineMaterial);
                        projectedCubeLines.add(line2D);
                    }
                }
            }
        }

        function setupEventListeners() {
            const view3D = document.getElementById('view3D');
            const view2D = document.getElementById('view2D');
            
            view3D.addEventListener('mousedown', (e) => {
                previousMousePosition.x = e.clientX;
                previousMousePosition.y = e.clientY;
                if (e.button === 0) {
                    isCubeDragging = true;
                } else if (e.button === 2) {
                    isSceneDragging = true;
                }
            });
            
            view2D.addEventListener('mousedown', (e) => {
                if(e.button === 0) {
                    isZooming2D = true;
                    previousMousePosition.y = e.clientY;
                }
            });

            view3D.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            window.addEventListener('mousemove', (e) => {
                if (!isCubeDragging && !isSceneDragging && !isZooming2D) return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                if (isCubeDragging) {
                    cube.rotateOnAxis(new THREE.Vector3(0, 1, 0), deltaX * 0.005);
                    cube.rotateOnAxis(new THREE.Vector3(1, 0, 0), deltaY * 0.005);
                    
                    cubeLocalRotation.y += deltaX * 0.005 * 180 / Math.PI;
                    cubeLocalRotation.x += deltaY * 0.005 * 180 / Math.PI;
                    
                    document.getElementById('cubeRotX').value = Math.round(cubeLocalRotation.x);
                    document.getElementById('cubeRotY').value = Math.round(cubeLocalRotation.y);
                    document.getElementById('cubeRotZ').value = Math.round(cubeLocalRotation.z);
                    
                    updateProjection();
                } else if (isSceneDragging) {
                    const yAxis = new THREE.Vector3(0, 1, 0);
                    const xAxis = new THREE.Vector3().setFromMatrixColumn(camera3D.matrix, 0);
                    camera3D.position.applyAxisAngle(yAxis, -deltaX * 0.005);
                    camera3D.position.applyAxisAngle(xAxis, -deltaY * 0.005);
                    camera3D.lookAt(scene3D.position);
                } else if (isZooming2D) {
                    zoomLevel2D += deltaY * 0.1;
                    zoomLevel2D = Math.max(10, Math.min(40, zoomLevel2D));
                    update2DCamera();
                }
                
                previousMousePosition.x = e.clientX;
                previousMousePosition.y = e.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                isCubeDragging = false;
                isSceneDragging = false;
                isZooming2D = false;
            });

            document.getElementById('viewpointY').addEventListener('input', (e) => {
                viewpointPosition.y = parseFloat(e.target.value);
                updateProjection();
            });

            document.getElementById('viewpointZ').addEventListener('input', (e) => {
                viewpointPosition.z = parseFloat(e.target.value);
                updateProjection();
            });

            document.getElementById('hemisphereRadius').addEventListener('input', (e) => {
                hemisphereRadius = parseFloat(e.target.value);
                
                scene3D.remove(hemisphere);
                const hemisphereGeometry = new THREE.SphereGeometry(hemisphereRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const hemisphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x0000ff, 
                    transparent: true, 
                    opacity: 0.15, 
                    side: THREE.DoubleSide 
                });
                hemisphere = new THREE.Mesh(hemisphereGeometry, hemisphereMaterial);
                hemisphere.position.copy(hemisphereCenter);
                // Flip hemisphere along z-axis so dome extends in +Z direction (away from cube)
                hemisphere.rotation.x = -Math.PI / 2;
                
                const hemisphereWireframe = new THREE.WireframeGeometry(hemisphereGeometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.3, transparent: true });
                const hemisphereWire = new THREE.LineSegments(hemisphereWireframe, wireframeMaterial);
                hemisphere.add(hemisphereWire);
                
                scene3D.add(hemisphere);
                updateProjection();
            });
            
            document.getElementById('zoom3D').addEventListener('input', (e) => {
                const newDistance = parseFloat(e.target.value);
                const currentDistance = camera3D.position.length();
                if (currentDistance > 0) {
                    const scale = newDistance / currentDistance;
                    camera3D.position.multiplyScalar(scale);
                }
            });

            document.getElementById('cubeRotX').addEventListener('input', (e) => {
                const newRotationX = parseFloat(e.target.value);
                const deltaX = newRotationX - cubeLocalRotation.x;
                cubeLocalRotation.x = newRotationX;
                
                cube.rotateOnAxis(new THREE.Vector3(1, 0, 0), deltaX * Math.PI / 180);
                updateProjection();
            });

            document.getElementById('cubeRotY').addEventListener('input', (e) => {
                const newRotationY = parseFloat(e.target.value);
                const deltaY = newRotationY - cubeLocalRotation.y;
                cubeLocalRotation.y = newRotationY;
                
                cube.rotateOnAxis(new THREE.Vector3(0, 1, 0), deltaY * Math.PI / 180);
                updateProjection();
            });

            document.getElementById('cubeRotZ').addEventListener('input', (e) => {
                const newRotationZ = parseFloat(e.target.value);
                const deltaZ = newRotationZ - cubeLocalRotation.z;
                cubeLocalRotation.z = newRotationZ;
                
                cube.rotateOnAxis(new THREE.Vector3(0, 0, 1), deltaZ * Math.PI / 180);
                updateProjection();
            });
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            const view3D = document.getElementById('view3D');
            
            camera3D.aspect = view3D.clientWidth / view3D.clientHeight;
            camera3D.updateProjectionMatrix();
            renderer3D.setSize(view3D.clientWidth, view3D.clientHeight);
            
            update2DCamera();
        }
        
        function update2DCamera() {
            const view2D = document.getElementById('view2D');
            const aspect = view2D.clientWidth / view2D.clientHeight;

            camera2D.left = -zoomLevel2D * aspect / 2;
            camera2D.right = zoomLevel2D * aspect / 2;
            camera2D.top = zoomLevel2D / 2;
            camera2D.bottom = -zoomLevel2D / 2;
            camera2D.updateProjectionMatrix();
            
            renderer2D.setSize(view2D.clientWidth, view2D.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer3D.render(scene3D, camera3D);
            renderer2D.render(scene2D, camera2D);
        }

        init();

    </script>
</body>
</html> 