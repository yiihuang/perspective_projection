<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combined Linear and Hemispherical Perspective</title>
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/windows.css">
    <link rel="stylesheet" href="css/controls.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module" src="js/main.js"></script>
</head>
<body>
    <div id="container">
        <div id="linear3D-window" class="window">
            <div class="window-header">
                <div class="window-title">Linear: 3D Scene (L-Click: Cube, R-Click: Scene)</div>
                <div class="window-controls">
                    <button class="window-button close-btn" onclick="toggleWindow('linear3D-window')">×</button>
                </div>
            </div>
            <div class="window-content">
                <div id="linear3D" class="view-content"></div>
            </div>
        </div>
        
        <div id="linear2D-window" class="window">
            <div class="window-header">
                <div class="window-title">Linear: 2D Projection (Drag/Wheel to Zoom)</div>
                <div class="window-controls">
                    <button class="window-button close-btn" onclick="toggleWindow('linear2D-window')">×</button>
                </div>
            </div>
            <div class="window-content">
                <div id="linear2D" class="view-content view-2d"></div>
            </div>
        </div>
        
        <div id="hemi3D-window" class="window">
            <div class="window-header">
                <div class="window-title">Hemispherical: 3D Scene (L-Click: Cube, R-Click: Scene)</div>
                <div class="window-controls">
                    <button class="window-button close-btn" onclick="toggleWindow('hemi3D-window')">×</button>
                </div>
            </div>
            <div class="window-content">
                <div id="hemi3D" class="view-content"></div>
            </div>
        </div>
        
        <div id="hemi2D-window" class="window">
            <div class="window-header">
                <div class="window-title">Hemispherical: 2D Projection (Drag/Wheel to Zoom)</div>
                <div class="window-controls">
                    <button class="window-button close-btn" onclick="toggleWindow('hemi2D-window')">×</button>
                </div>
            </div>
            <div class="window-content">
                <div id="hemi2D" class="view-content view-2d"></div>
            </div>
        </div>
    </div>

    <div id="window-menu-container">
        <button id="window-menu-toggle">Window</button>
        <div id="window-menu">
            <div class="window-menu-item" onclick="toggleWindow('linear3D-window')">
                <span class="checkmark">✓</span>
                <span>Linear 3D Scene</span>
            </div>
            <div class="window-menu-item" onclick="toggleWindow('linear2D-window')">
                <span class="checkmark">✓</span>
                <span>Linear 2D Projection</span>
            </div>
            <div class="window-menu-item" onclick="toggleWindow('hemi3D-window')">
                <span class="checkmark">✓</span>
                <span>Hemispherical 3D Scene</span>
            </div>
            <div class="window-menu-item" onclick="toggleWindow('hemi2D-window')">
                <span class="checkmark">✓</span>
                <span>Hemispherical 2D Projection</span>
            </div>
        </div>
    </div>

    <div id="controls-container">
        <button id="controls-toggle">Controls</button>
        <div id="controls">
            <div class="slider-container">
                <label for="viewpointY">Viewpoint Y</label>
                <div class="slider-row">
                    <input type="range" id="viewpointY" min="-10" max="10" value="2" step="0.1">
                    <input type="number" id="viewpointY-number" min="-10" max="10" value="2" step="0.1">
                </div>
            </div>
            <div class="slider-container">
                <label for="viewpointZ">Viewpoint Z</label>
                <div class="slider-row">
                    <input type="range" id="viewpointZ" min="3" max="20" value="8" step="0.1">
                    <input type="number" id="viewpointZ-number" min="3" max="20" value="8" step="0.1">
                </div>
            </div>
            <div class="slider-container">
                <label for="hemisphereRadius">Radius R (Both)</label>
                <div class="slider-row">
                    <input type="range" id="hemisphereRadius" min="1" max="15" value="6" step="0.1">
                    <input type="number" id="hemisphereRadius-number" min="1" max="15" value="6" step="0.1">
                </div>
            </div>
            <div class="slider-container">
                <label for="cubeRotX">Cube Rot X</label>
                <div class="slider-row">
                    <input type="range" id="cubeRotX" min="-180" max="180" value="0" step="1">
                    <input type="number" id="cubeRotX-number" min="-180" max="180" value="0" step="1">
                </div>
            </div>
            <div class="slider-container">
                <label for="cubeRotY">Cube Rot Y</label>
                <div class="slider-row">
                    <input type="range" id="cubeRotY" min="-180" max="180" value="0" step="1">
                    <input type="number" id="cubeRotY-number" min="-180" max="180" value="0" step="1">
                </div>
            </div>
            <div class="slider-container">
                <label for="cubeRotZ">Cube Rot Z</label>
                <div class="slider-row">
                    <input type="range" id="cubeRotZ" min="-180" max="180" value="0" step="1">
                    <input type="number" id="cubeRotZ-number" min="-180" max="180" value="0" step="1">
                </div>
            </div>
            <div class="slider-container">
                <label for="zoom3D">3D Zoom</label>
                <div class="slider-row">
                    <input type="range" id="zoom3D" min="10" max="40" value="16.5" step="0.1">
                    <input type="number" id="zoom3D-number" min="10" max="40" value="16.5" step="0.1">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Legacy window management functions for HTML onclick handlers
        function toggleWindow(windowId) {
            if (window.windowManager) {
                window.windowManager.toggleWindow(windowId);
            } else {
                console.warn('Window manager not yet initialized');
            }
        }
        
        // Export toggleWindow globally for HTML onclick handlers
        window.toggleWindow = toggleWindow;



            
            // Check if cube transform has changed
            if (!lastCubeMatrixWorld.equals(cube.matrixWorld) || !cachedWorldVertices) {
                const halfSize = CUBE_SIZE / 2;
                const localVertices = [
                    new THREE.Vector3(-halfSize, -halfSize, -halfSize), new THREE.Vector3( halfSize, -halfSize, -halfSize),
                    new THREE.Vector3( halfSize,  halfSize, -halfSize), new THREE.Vector3(-halfSize,  halfSize, -halfSize),
                    new THREE.Vector3(-halfSize, -halfSize,  halfSize), new THREE.Vector3( halfSize, -halfSize,  halfSize),
                    new THREE.Vector3( halfSize,  halfSize,  halfSize), new THREE.Vector3(-halfSize,  halfSize,  halfSize)
                ];
                
                cachedWorldVertices = localVertices.map(v => v.clone().applyMatrix4(cube.matrixWorld));
                lastCubeMatrixWorld.copy(cube.matrixWorld);
            }
            
            return cachedWorldVertices;
        }

        // Utility function to safely dispose Three.js objects
        function safeDispose(object) {
            if (!object) return;
            
            if (object.geometry) {
                object.geometry.dispose();
            }
            if (object.material) {
                if (Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                } else {
                    object.material.dispose();
                }
            }
            if (object.children) {
                object.children.forEach(child => safeDispose(child));
            }
        }

        // Helper function to clear and dispose group contents
        function clearGroup(group) {
            group.children.forEach(child => safeDispose(child));
            group.clear();
        }

        // Utility functions for common object management
        function findObjectByGeometryType(scene, geometryType) {
            return scene.children.find(child => child.geometry && child.geometry.type === geometryType);
        }

        function createMaterial(type, options = {}) {
            const defaults = {
                LineBasicMaterial: { color: 0x0077cc, linewidth: 2 },
                MeshBasicMaterial: { color: 0xff0000 },
                ProjectionLineMaterial: { color: 0xff0000, transparent: true, opacity: 0.5 },
                VanishingPointMaterial: { color: 0xff4136 },
                GuideMaterial: { color: 0xffaaaa, opacity: 0.4, transparent: true, linewidth: 1 }
            };
            
            const config = { ...defaults[type], ...options };
            
            switch (type) {
                case 'LineBasicMaterial':
                case 'ProjectionLineMaterial':
                case 'GuideMaterial':
                    return new THREE.LineBasicMaterial(config);
                case 'MeshBasicMaterial':
                case 'VanishingPointMaterial':
                    return new THREE.MeshBasicMaterial(config);
                default:
                    return new THREE.MeshBasicMaterial(config);
            }
        }

        function updateCubeInScene(sceneId, targetCube) {
            const sceneObject = findObjectByGeometryType(scenes[sceneId], 'BoxGeometry');
            if (sceneObject) {
                sceneObject.rotation.copy(targetCube.rotation);
                sceneObject.position.copy(targetCube.position);
            }
        }

        function updateViewpointInScene(sceneId, position) {
            const viewpointObject = findObjectByGeometryType(scenes[sceneId], 'SphereGeometry');
            if (viewpointObject) {
                viewpointObject.position.copy(position);
            }
        }

        function updateProjectedViewpointMarker(sceneId, x, y, z = 0.1) {
            const marker = findObjectByGeometryType(scenes[sceneId], 'RingGeometry');
            if (marker) {
                marker.position.set(x, y, z);
            }
        }

        // Window management functions
        function toggleWindow(windowId) {
            const window = document.getElementById(windowId);
            const isVisible = windowStates[windowId];
            
            if (isVisible) {
                window.style.display = 'none';
                windowStates[windowId] = false;
            } else {
                window.style.display = 'flex';
                windowStates[windowId] = true;
                
                // Force renderer update when window becomes visible
                const viewId = windowId.replace('-window', '');
                
                // Use multiple timeouts to ensure proper rendering
                setTimeout(() => {
                    if (renderers[viewId]) {
                        const viewElement = document.getElementById(viewId);
                        
                        // Force a reflow to ensure dimensions are available
                        viewElement.offsetHeight;
                        
                        // Update renderer size
                        renderers[viewId].setSize(viewElement.clientWidth, viewElement.clientHeight);
                        
                        // Update camera
                        if (cameras[viewId]) {
                            if (cameras[viewId].isPerspectiveCamera) {
                                cameras[viewId].aspect = viewElement.clientWidth / viewElement.clientHeight;
                                cameras[viewId].updateProjectionMatrix();
                            } else {
                                update2DCameras();
                            }
                        }
                        
                        // Mark viewport as dirty and force immediate render
                        viewportDirty[viewId] = true;
                        needsUpdate.render = true;
                        
                        // Force immediate render
                        renderers[viewId].render(scenes[viewId], cameras[viewId]);
                        
                        // Schedule additional updates to ensure everything is correct
                        setTimeout(() => {
                            viewportDirty[viewId] = true;
                            needsUpdate.render = true;
                            renderers[viewId].render(scenes[viewId], cameras[viewId]);
                        }, 50);
                    }
                }, 10);
                
                // Additional delayed update to catch any missed cases
                setTimeout(() => {
                    if (renderers[viewId]) {
                        const viewElement = document.getElementById(viewId);
                        renderers[viewId].setSize(viewElement.clientWidth, viewElement.clientHeight);
                        viewportDirty[viewId] = true;
                        needsUpdate.render = true;
                        renderers[viewId].render(scenes[viewId], cameras[viewId]);
                    }
                }, 200);
            }
            
            updateWindowMenuCheckmarks();
        }
        
        function updateWindowMenuCheckmarks() {
            const menuItems = document.querySelectorAll('.window-menu-item');
            const windowIds = ['linear3D-window', 'linear2D-window', 'hemi3D-window', 'hemi2D-window'];
            
            menuItems.forEach((item, index) => {
                const checkmark = item.querySelector('.checkmark');
                if (windowStates[windowIds[index]]) {
                    checkmark.style.visibility = 'visible';
                } else {
                    checkmark.style.visibility = 'hidden';
                }
            });
        }
        
        function initializeWindowDragging() {
            const windows = document.querySelectorAll('.window');
            
            windows.forEach(window => {
                const header = window.querySelector('.window-header');
                
                header.addEventListener('mousedown', (e) => {
                    // Don't drag if clicking on window controls
                    if (e.target.classList.contains('window-button')) return;
                    
                    dragState.isDragging = true;
                    dragState.currentWindow = window;
                    dragState.startX = e.clientX;
                    dragState.startY = e.clientY;
                    
                    const rect = window.getBoundingClientRect();
                    dragState.startLeft = rect.left;
                    dragState.startTop = rect.top;
                    
                    // Bring window to front
                    window.style.zIndex = '1000';
                    
                    e.preventDefault();
                });
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!dragState.isDragging || !dragState.currentWindow) return;
                
                const deltaX = e.clientX - dragState.startX;
                const deltaY = e.clientY - dragState.startY;
                
                const newLeft = dragState.startLeft + deltaX;
                const newTop = dragState.startTop + deltaY;
                
                // Keep window within viewport bounds
                const maxLeft = window.innerWidth - 200; // Min 200px visible width
                const maxTop = window.innerHeight - 50;   // Min 50px visible height
                
                dragState.currentWindow.style.left = Math.max(0, Math.min(maxLeft, newLeft)) + 'px';
                dragState.currentWindow.style.top = Math.max(0, Math.min(maxTop, newTop)) + 'px';
                dragState.currentWindow.style.right = 'auto';
                dragState.currentWindow.style.bottom = 'auto';
            });
            
            document.addEventListener('mouseup', () => {
                if (dragState.currentWindow) {
                    dragState.currentWindow.style.zIndex = '10';
                }
                dragState.isDragging = false;
                dragState.currentWindow = null;
            });
        }

        // Consolidated event listener setup with number input synchronization
        function setupSliderControl(elementId, updateCallback) {
            const slider = document.getElementById(elementId);
            const numberInput = document.getElementById(elementId + '-number');
            
            // Slider changes update number input
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                numberInput.value = value;
                if (updateCallback) {
                    updateCallback(value, e);
                }
                scheduleUpdate();
            });
            
            // Number input changes update slider
            numberInput.addEventListener('input', (e) => {
                let value = parseFloat(e.target.value);
                
                // Validate and clamp value to slider's min/max
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                
                if (isNaN(value)) {
                    value = parseFloat(slider.value); // Reset to current slider value
                    numberInput.value = value;
                    return;
                }
                
                value = Math.max(min, Math.min(max, value));
                
                // Update both inputs to the clamped value
                slider.value = value;
                numberInput.value = value;
                
                if (updateCallback) {
                    updateCallback(value, e);
                }
                scheduleUpdate();
            });
            
            // Handle number input blur to ensure valid values
            numberInput.addEventListener('blur', (e) => {
                let value = parseFloat(e.target.value);
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                
                if (isNaN(value)) {
                    value = parseFloat(slider.value);
                }
                
                value = Math.max(min, Math.min(max, value));
                numberInput.value = value;
                slider.value = value;
            });
        }

        function setupRotationControl(elementId, axis, rotationObj) {
            const slider = document.getElementById(elementId);
            const numberInput = document.getElementById(elementId + '-number');
            
            function handleRotationChange(e) {
                const newRotation = parseFloat(e.target.value);
                const delta = newRotation - rotationObj[axis];
                rotationObj[axis] = newRotation;
                
                const axisVector = new THREE.Vector3();
                axisVector[axis] = 1;
                cube.rotateOnAxis(axisVector, delta * Math.PI / 180);
                scheduleUpdate();
            }
            
            // Slider changes update number input and rotation
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                numberInput.value = value;
                handleRotationChange(e);
            });
            
            // Number input changes update slider and rotation
            numberInput.addEventListener('input', (e) => {
                let value = parseFloat(e.target.value);
                
                // Validate and clamp value
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                
                if (isNaN(value)) {
                    value = parseFloat(slider.value);
                    numberInput.value = value;
                    return;
                }
                
                value = Math.max(min, Math.min(max, value));
                slider.value = value;
                numberInput.value = value;
                
                handleRotationChange(e);
            });
            
            // Handle number input blur
            numberInput.addEventListener('blur', (e) => {
                let value = parseFloat(e.target.value);
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                
                if (isNaN(value)) {
                    value = parseFloat(slider.value);
                }
                
                value = Math.max(min, Math.min(max, value));
                numberInput.value = value;
                slider.value = value;
            });
        }

        function init() {
            setupScenes();
            createSceneObjects();
            setupEventListeners();
            initializeResizeObserver();
            animate();
        }

        function setupScenes() {
            const viewIds = ['linear3D', 'linear2D', 'hemi3D', 'hemi2D'];
            
            viewIds.forEach(id => {
                const viewElement = document.getElementById(id);
                const scene = new THREE.Scene();
                
                if (id.includes('3D')) {
                    scene.background = new THREE.Color(0xffffff);
                    const camera = new THREE.PerspectiveCamera(75, viewElement.clientWidth / viewElement.clientHeight, 0.1, 1000);
                    camera.position.set(8, 8, 12);
                    camera.lookAt(0, 0, 0);
                    cameras[id] = camera;
                    
                    // Add lighting
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(5, 10, 7.5);
                    scene.add(ambientLight, directionalLight);
                } else {
                    scene.background = new THREE.Color(0xf9fafb);
                    const camera = new THREE.OrthographicCamera(0, 0, 0, 0, 1, 1000);
                    camera.position.z = 5;
                    cameras[id] = camera;
                }
                
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(viewElement.clientWidth, viewElement.clientHeight);
                viewElement.appendChild(renderer.domElement);
                
                scenes[id] = scene;
                renderers[id] = renderer;
                
                // Initialize groups
                groups[id] = {
                    projectionLines: new THREE.Group(),
                    projectedCubeLines: new THREE.Group(),
                    vanishingPoints: new THREE.Group(),
                    extensionLines: new THREE.Group()
                };
                
                Object.values(groups[id]).forEach(group => scene.add(group));
            });
            
            update2DCameras();
        }

        function createSceneObjects() {
            // Create cube (shared across 3D scenes)
            const cubeGeometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x00aaff, opacity: 0.75, transparent: true });
            cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.z = -5;
            
            const edges = new THREE.EdgesGeometry(cubeGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x004466 });
            const cubeEdges = new THREE.LineSegments(edges, lineMaterial);
            cube.add(cubeEdges);
            
            // Add cube to 3D scenes
            scenes.linear3D.add(cube.clone());
            scenes.hemi3D.add(cube.clone());
            
            // Create viewpoint sphere (shared)
            const viewpointGeometry = new THREE.SphereGeometry(0.2, 32, 32);
            const viewpointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            viewpointSphere = new THREE.Mesh(viewpointGeometry, viewpointMaterial);
            
            scenes.linear3D.add(viewpointSphere.clone());
            scenes.hemi3D.add(viewpointSphere.clone());
            
            // Create image plane for linear perspective (size will be updated dynamically)
            const planeSize = 2 * hemisphereRadius;
            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
            imagePlane = new THREE.Mesh(planeGeometry, planeMaterial);
            imagePlane.position.set(viewpointPosition.x, viewpointPosition.y, getImagePlaneZ()); // Center at viewpoint height
            
            const planeEdges = new THREE.EdgesGeometry(planeGeometry);
            const planeEdgesMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.5 });
            const planeBorder = new THREE.LineSegments(planeEdges, planeEdgesMaterial);
            imagePlane.add(planeBorder);
            scenes.linear3D.add(imagePlane);
            
            // Create hemisphere for hemispherical perspective
            const hemisphereGeometry = new THREE.SphereGeometry(hemisphereRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const hemisphereMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
            hemisphere = new THREE.Mesh(hemisphereGeometry, hemisphereMaterial);
            hemisphere.rotation.x = -Math.PI / 2;
            
            const hemisphereWireframe = new THREE.WireframeGeometry(hemisphereGeometry);
            const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.3, transparent: true });
            const hemisphereWire = new THREE.LineSegments(hemisphereWireframe, wireframeMaterial);
            hemisphere.add(hemisphereWire);
            scenes.hemi3D.add(hemisphere);
            
            // Add grid helpers
            const gridHelper1 = new THREE.GridHelper(20, 20, 0xcccccc, 0xdddddd);
            const gridHelper2 = new THREE.GridHelper(20, 20, 0xcccccc, 0xdddddd);
            gridHelper1.position.y = -5;
            gridHelper2.position.y = -5;
            scenes.linear3D.add(gridHelper1);
            scenes.hemi3D.add(gridHelper2);
            
            // Create 2D boundaries
            createLinear2DBoundary();
            createHemi2DBoundary();
            
            // Create viewpoint markers for 2D scenes
            const pvRingGeom = new THREE.RingGeometry(0.15, 0.2, 24);
            const pvRingMat1 = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const pvRingMat2 = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const projectedViewpointMarker1 = new THREE.Mesh(pvRingGeom, pvRingMat1);
            const projectedViewpointMarker2 = new THREE.Mesh(pvRingGeom, pvRingMat2);
            scenes.linear2D.add(projectedViewpointMarker1);
            scenes.hemi2D.add(projectedViewpointMarker2);
            
            updateProjections();
        }

        function createLinear2DBoundary() {
            const halfSize = hemisphereRadius; // Half of 2R size
            // Fixed boundary centered at origin (reference frame)
            const planeBoundaryPoints = [
                new THREE.Vector3(-halfSize, -halfSize, 0), 
                new THREE.Vector3(halfSize, -halfSize, 0),
                new THREE.Vector3(halfSize, halfSize, 0), 
                new THREE.Vector3(-halfSize, halfSize, 0)
            ];
            const planeBoundaryGeom = new THREE.BufferGeometry().setFromPoints(planeBoundaryPoints);
            const planeBoundaryMat = new THREE.LineBasicMaterial({ color: 0x6667ab });
            window.linearBoundary = new THREE.LineLoop(planeBoundaryGeom, planeBoundaryMat);
            scenes.linear2D.add(window.linearBoundary);
        }

        function createHemi2DBoundary() {
            const boundaryRadius = (Math.PI / 2) * hemisphereRadius;
            const circleGeometry = new THREE.RingGeometry(boundaryRadius - 0.05, boundaryRadius, 64);
            const circleMaterial = new THREE.MeshBasicMaterial({ color: 0x6667ab, side: THREE.DoubleSide });
            window.hemiBoundary = new THREE.Mesh(circleGeometry, circleMaterial);
            scenes.hemi2D.add(window.hemiBoundary);
        }

        function update2DCameras() {
            ['linear2D', 'hemi2D'].forEach(id => {
                const viewElement = document.getElementById(id);
                const aspect = viewElement.clientWidth / viewElement.clientHeight;
                const camera = cameras[id];
                camera.left = -zoomLevel2D * aspect / 2;
                camera.right = zoomLevel2D * aspect / 2;
                camera.top = zoomLevel2D / 2;
                camera.bottom = -zoomLevel2D / 2;
                camera.updateProjectionMatrix();
            });
        }

        // Linear perspective projection functions
        function updateLinearProjection() {
            // Update cube and viewpoint positions using helper functions
            updateCubeInScene('linear3D', cube);
            updateViewpointInScene('linear3D', viewpointPosition);
            
            // Update image plane size, position and center at viewpoint height
            const currentImagePlaneZ = getImagePlaneZ();
            const newPlaneSize = 2 * hemisphereRadius;
            
            // Update image plane geometry if size changed
            if (imagePlane.geometry.parameters.width !== newPlaneSize) {
                // Dispose old geometries
                imagePlane.geometry.dispose();
                const planeBorder = imagePlane.children[0];
                if (planeBorder && planeBorder.geometry) {
                    planeBorder.geometry.dispose();
                }
                
                // Create new geometries
                imagePlane.geometry = new THREE.PlaneGeometry(newPlaneSize, newPlaneSize);
                if (planeBorder) {
                    planeBorder.geometry = new THREE.EdgesGeometry(imagePlane.geometry);
                }
            }
            
            // Position image plane at viewpoint height and correct Z distance
            imagePlane.position.set(viewpointPosition.x, viewpointPosition.y, currentImagePlaneZ);
            
            // Update 2D boundary - fixed at origin in reference frame
            if (window.linearBoundary) {
                scenes.linear2D.remove(window.linearBoundary);
                safeDispose(window.linearBoundary);
            }
            const boundaryHalfSize = hemisphereRadius;
            // Fixed boundary centered at origin (viewpoint projection is always at origin)
            const planeBoundaryPoints = [
                new THREE.Vector3(-boundaryHalfSize, -boundaryHalfSize, 0), 
                new THREE.Vector3(boundaryHalfSize, -boundaryHalfSize, 0),
                new THREE.Vector3(boundaryHalfSize, boundaryHalfSize, 0), 
                new THREE.Vector3(-boundaryHalfSize, boundaryHalfSize, 0)
            ];
            const planeBoundaryGeom = new THREE.BufferGeometry().setFromPoints(planeBoundaryPoints);
            const planeBoundaryMat = new THREE.LineBasicMaterial({ color: 0x6667ab });
            window.linearBoundary = new THREE.LineLoop(planeBoundaryGeom, planeBoundaryMat);
            scenes.linear2D.add(window.linearBoundary);
            
            // Clear previous projections
            Object.values(groups.linear2D).forEach(group => clearGroup(group));
            Object.values(groups.linear3D).forEach(group => clearGroup(group));
            
            // Update projected viewpoint marker (always at origin in reference frame)
            updateProjectedViewpointMarker('linear2D', 0, 0);
            
            // Project cube vertices (use cached vertices for better performance)
            const worldVertices = getCachedWorldVertices();
            const projectedVertices = [];

            // Draw projection lines and calculate 2D projections
            worldVertices.forEach(worldVertex => {
                const lineMat = createMaterial('ProjectionLineMaterial');
                groups.linear3D.projectionLines.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([viewpointPosition, worldVertex]), lineMat));
                
                const x = worldVertex.x - viewpointPosition.x;
                const y = worldVertex.y - viewpointPosition.y;
                const z = worldVertex.z - viewpointPosition.z;

                if (z !== 0) {
                     const x_proj = x * (currentImagePlaneZ - viewpointPosition.z) / z + viewpointPosition.x;
                     const y_proj = y * (currentImagePlaneZ - viewpointPosition.z) / z + viewpointPosition.y;
                     // Transform to reference frame where viewpoint projection is at origin
                     const x_ref = x_proj - viewpointPosition.x;
                     const y_ref = y_proj - viewpointPosition.y;
                     projectedVertices.push(new THREE.Vector2(x_ref, y_ref));
                } else {
                     projectedVertices.push(new THREE.Vector2(Infinity, Infinity));
                }
            });

            // Draw projected cube edges
            const edges = [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ];
            const projectedLineMaterial = createMaterial('LineBasicMaterial');
            for (let i = 0; i < edges.length; i += 2) {
                const p1 = projectedVertices[edges[i]];
                const p2 = projectedVertices[edges[i+1]];
                if (isFinite(p1.x) && isFinite(p1.y) && isFinite(p2.x) && isFinite(p2.y)) {
                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(p1.x, p1.y, 0),
                        new THREE.Vector3(p2.x, p2.y, 0)
                    ]), projectedLineMaterial);
                    groups.linear2D.projectedCubeLines.add(line);
                }
            }

            // Calculate and draw vanishing points
            const dirX = new THREE.Vector3().subVectors(worldVertices[1], worldVertices[0]);
            const dirY = new THREE.Vector3().subVectors(worldVertices[3], worldVertices[0]);
            const dirZ = new THREE.Vector3().subVectors(worldVertices[4], worldVertices[0]);

            const vanishingPoints = [
                { dir: dirX, color: 0xff4136, lightColor: 0xffaaaa }, // Red
                { dir: dirY, color: 0x2ecc40, lightColor: 0xaaffaa }, // Green
                { dir: dirZ, color: 0x0074d9, lightColor: 0xaaaaff }  // Blue
            ].map(item => {
                let vp = new THREE.Vector2(Infinity, Infinity);
                const dz = item.dir.z;
                if (Math.abs(dz) > 0.0001) {
                    const t = (currentImagePlaneZ - viewpointPosition.z) / dz;
                    const vp_x = viewpointPosition.x + t * item.dir.x;
                    const vp_y = viewpointPosition.y + t * item.dir.y;
                    // Transform to reference frame where viewpoint projection is at origin
                    vp.x = vp_x - viewpointPosition.x;
                    vp.y = vp_y - viewpointPosition.y;
                }
                return { point: vp, color: item.color, lightColor: item.lightColor };
            });

            vanishingPoints.forEach(vpData => {
                if (isFinite(vpData.point.x) && isFinite(vpData.point.y)) {
                    const vpGeom = new THREE.CircleGeometry(0.15, 16);
                    const vpMat = createMaterial('VanishingPointMaterial', { color: vpData.color });
                    const vpMesh = new THREE.Mesh(vpGeom, vpMat);
                    vpMesh.position.set(vpData.point.x, vpData.point.y, 0);
                    groups.linear2D.vanishingPoints.add(vpMesh);
                }
            });

            // Draw guide lines from cube edges to vanishing points
            const edgeAxisMapping = {
                0: [0, 1,  2, 3,  4, 5,  6, 7], // X-axis edges (indices of vertices)
                1: [0, 3,  1, 2,  4, 7,  5, 6], // Y-axis edges
                2: [0, 4,  1, 5,  2, 6,  3, 7]  // Z-axis edges
            };

            vanishingPoints.forEach((vpData, axisIndex) => {
                if (!isFinite(vpData.point.x) || !isFinite(vpData.point.y)) return;

                const guideMaterial = createMaterial('GuideMaterial', { color: vpData.lightColor });

                const axisVertices = edgeAxisMapping[axisIndex];
                for (const vertexIndex of axisVertices) {
                    const p1 = projectedVertices[vertexIndex];
                    if (isFinite(p1.x) && isFinite(p1.y)) {
                        const lineGeom = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(p1.x, p1.y, 0),
                            new THREE.Vector3(vpData.point.x, vpData.point.y, 0)
                        ]);
                        const line = new THREE.Line(lineGeom, guideMaterial);
                        groups.linear2D.extensionLines.add(line);
                    }
                }
            });
        }

        // Hemispherical perspective helper functions
        function intersectRayWithHemisphere(rayOrigin, rayDirection) {
            const oc = rayOrigin.clone().sub(hemisphereCenter);
            const a = rayDirection.dot(rayDirection);
            const b = 2.0 * oc.dot(rayDirection);
            const c = oc.dot(oc) - hemisphereRadius * hemisphereRadius;
            
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) return null;
            
            const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
            const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);
            
            for (let t of [t1, t2]) {
                if (t > 0.001) {
                    const point = rayOrigin.clone().add(rayDirection.clone().multiplyScalar(t));
                    if (point.z <= hemisphereCenter.z) {
                        return point;
                    }
                }
            }
            return null;
        }

        function postelProjection(point3D) {
            const relativePoint = point3D.clone().sub(hemisphereCenter);
            const x = relativePoint.x;
            const y = relativePoint.y;
            const z = relativePoint.z;
            
            const cosAlpha = -z / hemisphereRadius;
            const alpha = Math.acos(Math.max(-1, Math.min(1, cosAlpha)));
            const arcLength = alpha * hemisphereRadius;
            const theta = Math.atan2(y, x);
            
            const x2D = arcLength * Math.cos(theta);
            const y2D = arcLength * Math.sin(theta);
            
            return new THREE.Vector2(x2D, y2D);
        }

        function createCircularArc(p1, p2, p3, material) {
            const ax = p1.x, ay = p1.y;
            const bx = p2.x, by = p2.y; 
            const cx = p3.x, cy = p3.y;
            
            const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
            if (Math.abs(d) < 0.0001) {
                return new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(p1.x, p1.y, 0),
                    new THREE.Vector3(p2.x, p2.y, 0)
                ]), material);
            }
            
            const ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d;
            const uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d;
            
            const centerX = ux;
            const centerY = uy;
            const radius = Math.sqrt((ax - centerX) * (ax - centerX) + (ay - centerY) * (ay - centerY));
            
            const angle1 = Math.atan2(p1.y - centerY, p1.x - centerX);
            const angle2 = Math.atan2(p2.y - centerY, p2.x - centerX);
            
            const segments = 32;
            const points = [];
            
            let startAngle = angle1;
            let endAngle = angle2;
            let angleDiff = endAngle - startAngle;
            if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            endAngle = startAngle + angleDiff;
            
            for (let i = 0; i <= segments; i++) {
                const angle = startAngle + (endAngle - startAngle) * i / segments;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                points.push(new THREE.Vector3(x, y, 0));
            }
            
            return new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), material);
        }

        function updateHemisphericalProjection() {
            // Update cube and viewpoint positions using helper functions
            updateCubeInScene('hemi3D', cube);
            updateViewpointInScene('hemi3D', viewpointPosition);
            
            // Update hemisphere
            hemisphereCenter.copy(viewpointPosition);
            hemisphere.position.copy(hemisphereCenter);
            // No scaling needed - geometry is already created with correct radius
            
            // Update hemisphere boundary in 2D
            if (window.hemiBoundary) {
                scenes.hemi2D.remove(window.hemiBoundary);
                safeDispose(window.hemiBoundary);
            }
            createHemi2DBoundary();
            
            // Clear previous projections
            Object.values(groups.hemi2D).forEach(group => clearGroup(group));
            Object.values(groups.hemi3D).forEach(group => clearGroup(group));
            
            // Update projected viewpoint marker
            const hemisphereDir = hemisphereCenter.clone().sub(viewpointPosition).normalize();
            const viewpointOnHemisphere = intersectRayWithHemisphere(viewpointPosition, hemisphereDir);
            if (viewpointOnHemisphere) {
                const projected2D = postelProjection(viewpointOnHemisphere);
                updateProjectedViewpointMarker('hemi2D', projected2D.x, projected2D.y);
            }
            
            // Project cube vertices (use cached vertices for better performance)
            const worldVertices = getCachedWorldVertices();
            const projectedVertices = [];

            // Draw projection lines and calculate hemisphere intersections
            worldVertices.forEach(worldVertex => {
                const rayDirection = worldVertex.clone().sub(viewpointPosition).normalize();
                
                const lineMat = createMaterial('ProjectionLineMaterial', { opacity: 0.3 });
                const extendedPoint = viewpointPosition.clone().add(rayDirection.clone().multiplyScalar(30));
                groups.hemi3D.projectionLines.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([viewpointPosition, extendedPoint]), lineMat));
                
                const hemisphereIntersection = intersectRayWithHemisphere(viewpointPosition, rayDirection);
                if (hemisphereIntersection) {
                    const hemisphereLineMat = createMaterial('ProjectionLineMaterial', { color: 0x00ff00, opacity: 0.6 });
                    groups.hemi3D.projectionLines.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([viewpointPosition, hemisphereIntersection]), hemisphereLineMat));
                    
                    const projected2D = postelProjection(hemisphereIntersection);
                    projectedVertices.push(projected2D);
                } else {
                    projectedVertices.push(new THREE.Vector2(Infinity, Infinity));
                }
            });

            // Calculate vanishing points
            const dirX = new THREE.Vector3().subVectors(worldVertices[1], worldVertices[0]);
            const dirY = new THREE.Vector3().subVectors(worldVertices[3], worldVertices[0]);
            const dirZ = new THREE.Vector3().subVectors(worldVertices[4], worldVertices[0]);

            const vanishingPointData = [
                { dir: dirX.normalize(), color: 0xff4136 },
                { dir: dirY.normalize(), color: 0x2ecc40 },
                { dir: dirZ.normalize(), color: 0x0074d9 }
            ];

            const vanishingPoints = [];
            vanishingPointData.forEach(vpData => {
                const directions = [vpData.dir, vpData.dir.clone().negate()];
                
                directions.forEach((direction, index) => {
                    const hemisphereIntersection = intersectRayWithHemisphere(viewpointPosition, direction);
                    
                    if (hemisphereIntersection) {
                        const projected2D = postelProjection(hemisphereIntersection);
                        
                        if (isFinite(projected2D.x) && isFinite(projected2D.y)) {
                            vanishingPoints.push(projected2D);
                            
                            const vpGeom = new THREE.CircleGeometry(0.15, 16);
                            const vpMat = new THREE.MeshBasicMaterial({ 
                                color: vpData.color,
                                opacity: index === 0 ? 1.0 : 0.7,
                                transparent: index === 1
                            });
                            const vpMesh = new THREE.Mesh(vpGeom, vpMat);
                            vpMesh.position.set(projected2D.x, projected2D.y, 0.1);
                            groups.hemi2D.vanishingPoints.add(vpMesh);
                        } else {
                            vanishingPoints.push(null);
                        }
                    } else {
                        vanishingPoints.push(null);
                    }
                });
            });

            // Helper functions for arc drawing
            function getVanishingPointForEdge(v1Index, v2Index) {
                const boundaryRadius = (Math.PI / 2) * hemisphereRadius;
                const edgeDirections = {
                    '0,1': 0, '1,0': 0, '1,2': 1, '2,1': 1, '2,3': 0, '3,2': 0, '3,0': 1, '0,3': 1,
                    '4,5': 0, '5,4': 0, '5,6': 1, '6,5': 1, '6,7': 0, '7,6': 0, '7,4': 1, '4,7': 1,
                    '0,4': 2, '4,0': 2, '1,5': 2, '5,1': 2, '2,6': 2, '6,2': 2, '3,7': 2, '7,3': 2
                };
                
                const key = `${v1Index},${v2Index}`;
                let axisIndex = edgeDirections[key];
                if (axisIndex === undefined) return { vp: null, axisIndex: null };
                
                const posVP = vanishingPoints[axisIndex * 2];
                const negVP = vanishingPoints[axisIndex * 2 + 1];
                
                if (posVP && (posVP.x * posVP.x + posVP.y * posVP.y) <= boundaryRadius * boundaryRadius) {
                    return { vp: posVP, axisIndex: axisIndex };
                }
                if (negVP && (negVP.x * negVP.x + negVP.y * negVP.y) <= boundaryRadius * boundaryRadius) {
                    return { vp: negVP, axisIndex: axisIndex };
                }
                
                return { vp: null, axisIndex: axisIndex };
            }

            function getLighterColor(axisIndex) {
                const colors = [0xffaaaa, 0xaaffaa, 0xaaaaff];
                return colors[axisIndex];
            }

            // Draw projected cube edges as circular arcs
            const edges = [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ];
            const projectedLineMaterial = new THREE.LineBasicMaterial({ color: 0x0077cc, linewidth: 2 });
            
            for (let i = 0; i < edges.length; i += 2) {
                const v1Index = edges[i];
                const v2Index = edges[i+1];
                const p1 = projectedVertices[v1Index];
                const p2 = projectedVertices[v2Index];
                
                if (p1 && p2 && isFinite(p1.x) && isFinite(p1.y) && isFinite(p2.x) && isFinite(p2.y)) {
                    const vpResult = getVanishingPointForEdge(v1Index, v2Index);
                    
                    if (vpResult.vp) {
                        const arc = createCircularArc(p1, p2, vpResult.vp, projectedLineMaterial);
                        groups.hemi2D.projectedCubeLines.add(arc);
                        
                        // Draw guide lines
                        const guideColor = getLighterColor(vpResult.axisIndex);
                        const guideMaterial = new THREE.LineBasicMaterial({ 
                            color: guideColor, 
                            opacity: 0.4, 
                            transparent: true,
                            linewidth: 1
                        });
                        
                        const guide1 = createCircularArc(p1, vpResult.vp, p2, guideMaterial);
                        const guide2 = createCircularArc(p2, vpResult.vp, p1, guideMaterial);
                        
                        groups.hemi2D.projectedCubeLines.add(guide1);
                        groups.hemi2D.projectedCubeLines.add(guide2);
                    } else {
                        const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(p1.x, p1.y, 0),
                            new THREE.Vector3(p2.x, p2.y, 0)
                        ]), projectedLineMaterial);
                        groups.hemi2D.projectedCubeLines.add(line);
                    }
                }
            }
        }

        function updateProjections() {
            // Simplified change detection - still use caching but be less aggressive
            const currentHash = generateUpdateHash();
            if (currentHash === lastUpdateHash) {
                return; // No changes, skip update
            }
            lastUpdateHash = currentHash;
            
            // Always update both projections when needed
            updateLinearProjection();
            updateHemisphericalProjection();
            
            needsUpdate.linear = false;
            needsUpdate.hemi = false;
        }

        function setupEventListeners() {
            // Mouse interaction variables
            let isDraggingCube = false;
            let isDraggingScene = false;
            let isZooming2D = false;
            let previousMousePosition = { x: 0, y: 0 };

            // Add mouse event listeners to 3D view elements (for cube and scene rotation)
            const view3DElements = [document.getElementById('linear3D'), document.getElementById('hemi3D')];
            
            // Prevent window dragging when interacting with 3D views
            view3DElements.forEach(element => {
                element.addEventListener('mousedown', (e) => {
                    e.stopPropagation(); // Prevent window dragging
                });
            });
            
            view3DElements.forEach(viewElement => {
                viewElement.addEventListener('mousedown', (e) => {
                    // Prevent dragging if clicking on controls
                    if (e.target.closest('#controls')) return;
                    
                    if (e.button === 0) { // Left click - rotate cube
                        isDraggingCube = true;
                    } else if (e.button === 2) { // Right click - rotate scene
                        isDraggingScene = true;
                    }
                    
                    previousMousePosition.x = e.clientX;
                    previousMousePosition.y = e.clientY;
                    e.preventDefault(); // Prevent text selection
                });

                viewElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault(); // Prevent right-click context menu
                });
            });

            // Add mouse event listeners to 2D view elements (for zooming)
            const view2DElements = [document.getElementById('linear2D'), document.getElementById('hemi2D')];
            
            // Prevent window dragging when interacting with 2D views
            view2DElements.forEach(element => {
                element.addEventListener('mousedown', (e) => {
                    e.stopPropagation(); // Prevent window dragging
                });
            });
            
            view2DElements.forEach(viewElement => {
                viewElement.addEventListener('mousedown', (e) => {
                    // Prevent zooming if clicking on controls
                    if (e.target.closest('#controls')) return;
                    
                    isZooming2D = true;
                    previousMousePosition.y = e.clientY;
                    e.preventDefault(); // Prevent text selection
                });

                // Add wheel event for zooming
                viewElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.5;
                    const delta = e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
                    
                    zoomLevel2D += delta;
                    zoomLevel2D = Math.max(5, Math.min(100, zoomLevel2D)); // Clamp zoom level
                    update2DCameras();
                    lastActivity = Date.now(); // Track wheel zoom activity
                    scheduleUpdate('zoom2D'); // Only 2D viewports need zoom updates
                });
            });

            // Global mouse move event (handles cube rotation, scene rotation, and 2D zoom)
            window.addEventListener('mousemove', (e) => {
                if (isDraggingCube) {
                    // Handle cube rotation (left click)
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    cube.rotateOnAxis(new THREE.Vector3(0, 1, 0), deltaX * 0.005);
                    cube.rotateOnAxis(new THREE.Vector3(1, 0, 0), deltaY * 0.005);
                    
                    cubeLocalRotation.y += deltaX * 0.005 * 180 / Math.PI;
                    cubeLocalRotation.x += deltaY * 0.005 * 180 / Math.PI;
                    
                    // Update both slider and number input
                    const rotXValue = Math.round(cubeLocalRotation.x);
                    const rotYValue = Math.round(cubeLocalRotation.y);
                    
                    document.getElementById('cubeRotX').value = rotXValue;
                    document.getElementById('cubeRotX-number').value = rotXValue;
                    document.getElementById('cubeRotY').value = rotYValue;
                    document.getElementById('cubeRotY-number').value = rotYValue;
                    
                    scheduleUpdate('all', true); // Immediate update for mouse interaction
                    
                    previousMousePosition.x = e.clientX;
                    previousMousePosition.y = e.clientY;
                } else if (isDraggingScene) {
                    // Handle scene rotation (right click) - rotate cameras around origin
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    // Rotate both 3D cameras
                    ['linear3D', 'hemi3D'].forEach(id => {
                        const camera = cameras[id];
                        
                        // Horizontal rotation (around Y axis)
                        const yAxis = new THREE.Vector3(0, 1, 0);
                        const rotationY = new THREE.Matrix4().makeRotationAxis(yAxis, -deltaX * 0.005);
                        camera.position.applyMatrix4(rotationY);
                        
                        // Vertical rotation (around camera's local X axis)
                        const xAxis = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 0);
                        const rotationX = new THREE.Matrix4().makeRotationAxis(xAxis, -deltaY * 0.005);
                        camera.position.applyMatrix4(rotationX);
                        
                        // Keep camera looking at origin
                        camera.lookAt(0, 0, 0);
                    });
                    
                    lastActivity = Date.now(); // Track camera movement activity
                    scheduleUpdate('camera'); // Only 3D viewports need camera updates
                    previousMousePosition.x = e.clientX;
                    previousMousePosition.y = e.clientY;
                } else if (isZooming2D) {
                    // Handle 2D zoom
                    const deltaY = e.clientY - previousMousePosition.y;
                    const zoomSpeed = 0.1;
                    
                    zoomLevel2D += deltaY * zoomSpeed;
                    zoomLevel2D = Math.max(5, Math.min(100, zoomLevel2D)); // Clamp zoom level
                    update2DCameras();
                    lastActivity = Date.now(); // Track zoom activity
                    scheduleUpdate('zoom2D'); // Only 2D viewports need zoom updates
                    
                    previousMousePosition.y = e.clientY;
                }
            });

            window.addEventListener('mouseup', () => {
                isDraggingCube = false;
                isDraggingScene = false;
                isZooming2D = false;
            });

            // Prevent drag interaction when using controls
            document.getElementById('controls').addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event from bubbling up
            });
            
            // Handle controls dropdown toggle
            const controlsToggle = document.getElementById('controls-toggle');
            const controlsPanel = document.getElementById('controls');
            
            controlsToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                controlsPanel.classList.toggle('show');
            });
            
            // Close controls when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#controls-container')) {
                    controlsPanel.classList.remove('show');
                }
            });
            
            // Prevent controls from closing when clicking inside the panel
            controlsPanel.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            
            // Handle window menu dropdown toggle
            const windowMenuToggle = document.getElementById('window-menu-toggle');
            const windowMenu = document.getElementById('window-menu');
            
            windowMenuToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                windowMenu.classList.toggle('show');
            });
            
            // Close window menu when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#window-menu-container')) {
                    windowMenu.classList.remove('show');
                }
            });
            
            // Prevent window menu from closing when clicking inside
            windowMenu.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            
            // Initialize window dragging
            initializeWindowDragging();
            
            // Handle page visibility changes to fix rendering issues
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    // Page became visible, force re-render all visible windows
                    setTimeout(() => {
                        Object.keys(renderers).forEach(id => {
                            const windowId = id + '-window';
                            if (windowStates[windowId]) {
                                const viewElement = document.getElementById(id);
                                if (viewElement && renderers[id] && cameras[id]) {
                                    renderers[id].setSize(viewElement.clientWidth, viewElement.clientHeight);
                                    viewportDirty[id] = true;
                                    needsUpdate.render = true;
                                    renderers[id].render(scenes[id], cameras[id]);
                                }
                            }
                        });
                    }, 100);
                }
            });

            // Slider controls (fixed setup)
            setupSliderControl('viewpointY', (value) => {
                viewpointPosition.y = value;
            });
            
            setupSliderControl('viewpointZ', (value) => {
                viewpointPosition.z = value;
            });
            
            setupSliderControl('hemisphereRadius', (value) => {
                hemisphereRadius = value;
                
                // Recreate hemisphere with new radius
                scenes.hemi3D.remove(hemisphere);
                safeDispose(hemisphere); // Dispose old hemisphere and its children
                
                const hemisphereGeometry = new THREE.SphereGeometry(hemisphereRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const hemisphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x0000ff, 
                    transparent: true, 
                    opacity: 0.15, 
                    side: THREE.DoubleSide 
                });
                hemisphere = new THREE.Mesh(hemisphereGeometry, hemisphereMaterial);
                hemisphere.position.copy(hemisphereCenter);
                hemisphere.rotation.x = -Math.PI / 2;
                
                const hemisphereWireframe = new THREE.WireframeGeometry(hemisphereGeometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.3, transparent: true });
                const hemisphereWire = new THREE.LineSegments(hemisphereWireframe, wireframeMaterial);
                hemisphere.add(hemisphereWire);
                
                scenes.hemi3D.add(hemisphere);
            });

            setupRotationControl('cubeRotX', 'x', cubeLocalRotation);
            setupRotationControl('cubeRotY', 'y', cubeLocalRotation);
            setupRotationControl('cubeRotZ', 'z', cubeLocalRotation);

            setupSliderControl('zoom3D', (value) => {
                const newDistance = value;
                ['linear3D', 'hemi3D'].forEach(id => {
                    const camera = cameras[id];
                    const currentDistance = camera.position.length();
                    if (currentDistance > 0) {
                        const scale = newDistance / currentDistance;
                        camera.position.multiplyScalar(scale);
                    }
                });
            });

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            Object.keys(renderers).forEach(id => {
                const viewElement = document.getElementById(id);
                const camera = cameras[id];
                const renderer = renderers[id];
                
                if (camera.isPerspectiveCamera) {
                    camera.aspect = viewElement.clientWidth / viewElement.clientHeight;
                    camera.updateProjectionMatrix();
                } else {
                    const aspect = viewElement.clientWidth / viewElement.clientHeight;
                    camera.left = -zoomLevel2D * aspect / 2;
                    camera.right = zoomLevel2D * aspect / 2;
                    camera.top = zoomLevel2D / 2;
                    camera.bottom = -zoomLevel2D / 2;
                    camera.updateProjectionMatrix();
                }
                
                renderer.setSize(viewElement.clientWidth, viewElement.clientHeight);
            });
        }
        
        function initializeResizeObserver() {
            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(entries => {
                    entries.forEach(entry => {
                        const element = entry.target;
                        const id = element.id;
                        
                        // Skip if element has no dimensions (likely hidden)
                        if (element.clientWidth === 0 || element.clientHeight === 0) {
                            return;
                        }
                        
                        if (renderers[id]) {
                            const camera = cameras[id];
                            const renderer = renderers[id];
                            
                            if (camera.isPerspectiveCamera) {
                                camera.aspect = element.clientWidth / element.clientHeight;
                                camera.updateProjectionMatrix();
                            } else {
                                update2DCameras();
                            }
                            
                            renderer.setSize(element.clientWidth, element.clientHeight);
                            
                            // Force immediate render after resize
                            viewportDirty[id] = true;
                            needsUpdate.render = true;
                            renderer.render(scenes[id], camera);
                        }
                    });
                });
                
                // Observe all view elements
                ['linear3D', 'linear2D', 'hemi3D', 'hemi2D'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        resizeObserver.observe(element);
                    }
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const deltaTime = now - lastFrameTime;
            const timeSinceLastActivity = now - lastActivity;
            
            // Smart frame rate scaling
            isIdle = timeSinceLastActivity > 1000; // Consider idle after 1 second
            if (isIdle) {
                targetFPS = 30; // Reduce to 30fps when idle
                frameInterval = 1000 / targetFPS;
            }
            
            // Frame rate limiting
            if (deltaTime < frameInterval) {
                return; // Skip this frame
            }
            
            lastFrameTime = now;
            frameCount++;
            renderStats.totalFrames++;
            
            // Selective rendering: only render viewports that are dirty
            let rendered = false;
            const renderStartTime = performance.now();
            
            if (!isIdle || needsUpdate.render) {
                Object.keys(renderers).forEach(id => {
                    if (viewportDirty[id] || !isIdle) {
                        renderers[id].render(scenes[id], cameras[id]);
                        viewportDirty[id] = false;
                        rendered = true;
                    }
                });
                
                if (rendered) {
                    needsUpdate.render = false;
                }
            }
            
            // Update render stats
            if (rendered) {
                renderStats.renderTime = performance.now() - renderStartTime;
            } else {
                renderStats.skippedFrames++;
            }
            
            // Calculate FPS every second
            if (frameCount % 60 === 0) {
                const timeDiff = now - (renderStats.lastFPSTime || now);
                if (timeDiff > 0) {
                    renderStats.lastFPS = Math.round(60000 / timeDiff);
                }
                renderStats.lastFPSTime = now;
            }
        }

        // Initialize the application
        window.addEventListener('load', init);
    </script>
</body>
</html> 