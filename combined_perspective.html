<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combined Linear and Hemispherical Perspective</title>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #f0f2f5;
            color: #333;
        }
        #container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            width: 100vw;
            height: 100vh;
            gap: 2px;
        }
        .view {
            position: relative;
            border: 1px solid #d1d5db;
            background-color: #ffffff;
        }
        #linear3D { 
            background-color: #ffffff; 
            cursor: grab;
        }
        #linear3D:active {
            cursor: grabbing;
        }
        #linear2D { 
            background-color: #f9fafb; 
            cursor: ns-resize;
        }
        #linear2D:active {
            cursor: ns-resize;
        }
        #hemi3D { 
            background-color: #ffffff; 
            cursor: grab;
        }
        #hemi3D:active {
            cursor: grabbing;
        }
        #hemi2D { 
            background-color: #f9fafb; 
            cursor: ns-resize;
        }
        #hemi2D:active {
            cursor: ns-resize;
        }
        
        canvas { display: block; width: 100%; height: 100%; }
        
        h2 {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            padding: 4px 8px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 6px;
            font-size: 0.8em;
            font-weight: 500;
            text-align: center;
            z-index: 10;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            z-index: 100;
            max-width: 90vw;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 200px;
        }
        
        .slider-container label {
            font-size: 0.8em;
            width: 80px;
            flex-shrink: 0;
        }
        
        .slider-container input[type="range"] {
            flex: 1;
            min-width: 100px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="container">
        <div id="linear3D" class="view">
            <h2>Linear: 3D Scene (L-Click: Cube, R-Click: Scene)</h2>
        </div>
        <div id="linear2D" class="view">
            <h2>Linear: 2D Projection (Drag/Wheel to Zoom)</h2>
        </div>
        <div id="hemi3D" class="view">
            <h2>Hemispherical: 3D Scene (L-Click: Cube, R-Click: Scene)</h2>
        </div>
        <div id="hemi2D" class="view">
            <h2>Hemispherical: 2D Projection (Drag/Wheel to Zoom)</h2>
        </div>
    </div>

    <div id="controls">
        <div class="slider-container">
            <label for="viewpointY">Viewpoint Y</label>
            <input type="range" id="viewpointY" min="-10" max="10" value="2" step="0.1">
        </div>
        <div class="slider-container">
            <label for="viewpointZ">Viewpoint Z</label>
            <input type="range" id="viewpointZ" min="3" max="20" value="8" step="0.1">
        </div>

        <div class="slider-container">
            <label for="hemisphereRadius">Radius R (Both)</label>
            <input type="range" id="hemisphereRadius" min="1" max="15" value="6" step="0.1">
        </div>
        <div class="slider-container">
            <label for="cubeRotX">Cube Rot X</label>
            <input type="range" id="cubeRotX" min="-180" max="180" value="0" step="1">
        </div>
        <div class="slider-container">
            <label for="cubeRotY">Cube Rot Y</label>
            <input type="range" id="cubeRotY" min="-180" max="180" value="0" step="1">
        </div>
        <div class="slider-container">
            <label for="cubeRotZ">Cube Rot Z</label>
            <input type="range" id="cubeRotZ" min="-180" max="180" value="0" step="1">
        </div>
        <div class="slider-container">
            <label for="zoom3D">3D Zoom</label>
            <input type="range" id="zoom3D" min="10" max="40" value="16.5" step="0.1">
        </div>
    </div>

    <script>
        // Global variables
        let scenes = {}, cameras = {}, renderers = {};
        let cube, viewpointSphere, imagePlane, hemisphere;
        let hemisphereCenter = new THREE.Vector3();
        
        // Parameters
        const CUBE_SIZE = 4;
        let hemisphereRadius = 6;
        let viewpointPosition = new THREE.Vector3(0, 2, 8);
        
        // Image plane Z position is now calculated dynamically based on viewpoint and hemisphere radius
        function getImagePlaneZ() {
            return viewpointPosition.z - hemisphereRadius;
        }
        let cubeLocalRotation = { x: 0, y: 0, z: 0 };
        
        // Groups for different elements
        let groups = {};
        let zoomLevel2D = 25;

        // Performance optimization: Change tracking and caching
        let needsUpdate = {
            linear: true,
            hemi: true,
            render: true
        };
        
        // Viewport-specific dirty tracking for selective rendering
        let viewportDirty = {
            linear3D: true,
            linear2D: true,
            hemi3D: true,
            hemi2D: true
        };
        
        let cachedWorldVertices = null;
        let lastCubeMatrixWorld = new THREE.Matrix4();
        let lastUpdateHash = '';
        
        // Rendering efficiency variables
        let updateTimeout = null;
        let lastActivity = Date.now();
        let isIdle = false;
        let frameCount = 0;
        let lastFrameTime = Date.now();
        let targetFPS = 60;
        let frameInterval = 1000 / targetFPS;
        
        // Performance monitoring (optional)
        let renderStats = {
            totalFrames: 0,
            skippedFrames: 0,
            lastFPS: 60,
            renderTime: 0,
            lastFPSTime: Date.now()
        };
        
        // Performance debug function (accessible from console)
        window.getRenderStats = function() {
            const efficiency = renderStats.totalFrames > 0 ? 
                (1 - renderStats.skippedFrames / renderStats.totalFrames) * 100 : 100;
            return {
                ...renderStats,
                efficiency: `${efficiency.toFixed(1)}%`,
                currentFPS: targetFPS,
                isIdle: isIdle
            };
        };
        
        // Optional: Add performance overlay (uncomment to enable)
        /*
        function createPerformanceOverlay() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 10px; right: 10px; 
                background: rgba(0,0,0,0.8); color: white; 
                padding: 10px; font-family: monospace; font-size: 12px;
                border-radius: 5px; z-index: 1000;
            `;
            document.body.appendChild(overlay);
            
            setInterval(() => {
                const stats = getRenderStats();
                overlay.innerHTML = `
                    FPS: ${stats.lastFPS}<br>
                    Target: ${stats.currentFPS}<br>
                    Efficiency: ${stats.efficiency}<br>
                    Render Time: ${stats.renderTime.toFixed(2)}ms<br>
                    Status: ${stats.isIdle ? 'Idle' : 'Active'}
                `;
            }, 500);
        }
        // createPerformanceOverlay(); // Uncomment to enable overlay
        */
        
        function scheduleUpdate(updateType = 'all', immediate = false) {
            lastActivity = Date.now(); // Track user activity
            
            // Mark viewports as dirty based on update type
            if (updateType === 'all') {
                Object.keys(viewportDirty).forEach(key => viewportDirty[key] = true);
                needsUpdate.linear = true;
                needsUpdate.hemi = true;
            } else if (updateType === 'linear') {
                viewportDirty.linear3D = true;
                viewportDirty.linear2D = true;
                needsUpdate.linear = true;
            } else if (updateType === 'hemi') {
                viewportDirty.hemi3D = true;
                viewportDirty.hemi2D = true;
                needsUpdate.hemi = true;
            } else if (updateType === 'camera') {
                // Only 3D viewports need update for camera changes
                viewportDirty.linear3D = true;
                viewportDirty.hemi3D = true;
            } else if (updateType === 'zoom2D') {
                // Only 2D viewports need update for zoom changes
                viewportDirty.linear2D = true;
                viewportDirty.hemi2D = true;
            }
            
            needsUpdate.render = true;
            
            // Boost frame rate during interaction
            targetFPS = 60;
            frameInterval = 1000 / targetFPS;
            
            if (immediate) {
                // For interactive updates, update immediately
                if (needsUpdate.linear || needsUpdate.hemi) {
                    updateProjections();
                }
                return;
            }
            
            // Only debounce slider updates, not mouse interactions
            if (updateTimeout) clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                if (needsUpdate.linear || needsUpdate.hemi) {
                    updateProjections();
                }
                updateTimeout = null;
            }, 8); // Reduced debouncing for better responsiveness
        }
        
        function generateUpdateHash() {
            return `${viewpointPosition.x},${viewpointPosition.y},${viewpointPosition.z},${hemisphereRadius},${cube.rotation.x},${cube.rotation.y},${cube.rotation.z},${cube.position.x},${cube.position.y},${cube.position.z}`;
        }
        
        function getCachedWorldVertices() {
            cube.updateMatrixWorld();
            
            // Check if cube transform has changed
            if (!lastCubeMatrixWorld.equals(cube.matrixWorld) || !cachedWorldVertices) {
                const halfSize = CUBE_SIZE / 2;
                const localVertices = [
                    new THREE.Vector3(-halfSize, -halfSize, -halfSize), new THREE.Vector3( halfSize, -halfSize, -halfSize),
                    new THREE.Vector3( halfSize,  halfSize, -halfSize), new THREE.Vector3(-halfSize,  halfSize, -halfSize),
                    new THREE.Vector3(-halfSize, -halfSize,  halfSize), new THREE.Vector3( halfSize, -halfSize,  halfSize),
                    new THREE.Vector3( halfSize,  halfSize,  halfSize), new THREE.Vector3(-halfSize,  halfSize,  halfSize)
                ];
                
                cachedWorldVertices = localVertices.map(v => v.clone().applyMatrix4(cube.matrixWorld));
                lastCubeMatrixWorld.copy(cube.matrixWorld);
            }
            
            return cachedWorldVertices;
        }

        // Utility function to safely dispose Three.js objects
        function safeDispose(object) {
            if (!object) return;
            
            if (object.geometry) {
                object.geometry.dispose();
            }
            if (object.material) {
                if (Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                } else {
                    object.material.dispose();
                }
            }
            if (object.children) {
                object.children.forEach(child => safeDispose(child));
            }
        }

        // Helper function to clear and dispose group contents
        function clearGroup(group) {
            group.children.forEach(child => safeDispose(child));
            group.clear();
        }

        // Utility functions for common object management
        function findObjectByGeometryType(scene, geometryType) {
            return scene.children.find(child => child.geometry && child.geometry.type === geometryType);
        }

        function createMaterial(type, options = {}) {
            const defaults = {
                LineBasicMaterial: { color: 0x0077cc, linewidth: 2 },
                MeshBasicMaterial: { color: 0xff0000 },
                ProjectionLineMaterial: { color: 0xff0000, transparent: true, opacity: 0.5 },
                VanishingPointMaterial: { color: 0xff4136 },
                GuideMaterial: { color: 0xffaaaa, opacity: 0.4, transparent: true, linewidth: 1 }
            };
            
            const config = { ...defaults[type], ...options };
            
            switch (type) {
                case 'LineBasicMaterial':
                case 'ProjectionLineMaterial':
                case 'GuideMaterial':
                    return new THREE.LineBasicMaterial(config);
                case 'MeshBasicMaterial':
                case 'VanishingPointMaterial':
                    return new THREE.MeshBasicMaterial(config);
                default:
                    return new THREE.MeshBasicMaterial(config);
            }
        }

        function updateCubeInScene(sceneId, targetCube) {
            const sceneObject = findObjectByGeometryType(scenes[sceneId], 'BoxGeometry');
            if (sceneObject) {
                sceneObject.rotation.copy(targetCube.rotation);
                sceneObject.position.copy(targetCube.position);
            }
        }

        function updateViewpointInScene(sceneId, position) {
            const viewpointObject = findObjectByGeometryType(scenes[sceneId], 'SphereGeometry');
            if (viewpointObject) {
                viewpointObject.position.copy(position);
            }
        }

        function updateProjectedViewpointMarker(sceneId, x, y, z = 0.1) {
            const marker = findObjectByGeometryType(scenes[sceneId], 'RingGeometry');
            if (marker) {
                marker.position.set(x, y, z);
            }
        }

        // Consolidated event listener setup
        function setupSliderControl(elementId, updateCallback) {
            document.getElementById(elementId).addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                if (updateCallback) {
                    updateCallback(value, e);
                }
                scheduleUpdate();
            });
        }

        function setupRotationControl(elementId, axis, rotationObj) {
            document.getElementById(elementId).addEventListener('input', (e) => {
                const newRotation = parseFloat(e.target.value);
                const delta = newRotation - rotationObj[axis];
                rotationObj[axis] = newRotation;
                
                const axisVector = new THREE.Vector3();
                axisVector[axis] = 1;
                cube.rotateOnAxis(axisVector, delta * Math.PI / 180);
                scheduleUpdate();
            });
        }

        function init() {
            setupScenes();
            createSceneObjects();
            setupEventListeners();
            animate();
        }

        function setupScenes() {
            const viewIds = ['linear3D', 'linear2D', 'hemi3D', 'hemi2D'];
            
            viewIds.forEach(id => {
                const viewElement = document.getElementById(id);
                const scene = new THREE.Scene();
                
                if (id.includes('3D')) {
                    scene.background = new THREE.Color(0xffffff);
                    const camera = new THREE.PerspectiveCamera(75, viewElement.clientWidth / viewElement.clientHeight, 0.1, 1000);
                    camera.position.set(8, 8, 12);
                    camera.lookAt(0, 0, 0);
                    cameras[id] = camera;
                    
                    // Add lighting
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(5, 10, 7.5);
                    scene.add(ambientLight, directionalLight);
                } else {
                    scene.background = new THREE.Color(0xf9fafb);
                    const camera = new THREE.OrthographicCamera(0, 0, 0, 0, 1, 1000);
                    camera.position.z = 5;
                    cameras[id] = camera;
                }
                
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(viewElement.clientWidth, viewElement.clientHeight);
                viewElement.appendChild(renderer.domElement);
                
                scenes[id] = scene;
                renderers[id] = renderer;
                
                // Initialize groups
                groups[id] = {
                    projectionLines: new THREE.Group(),
                    projectedCubeLines: new THREE.Group(),
                    vanishingPoints: new THREE.Group(),
                    extensionLines: new THREE.Group()
                };
                
                Object.values(groups[id]).forEach(group => scene.add(group));
            });
            
            update2DCameras();
        }

        function createSceneObjects() {
            // Create cube (shared across 3D scenes)
            const cubeGeometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x00aaff, opacity: 0.75, transparent: true });
            cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.z = -5;
            
            const edges = new THREE.EdgesGeometry(cubeGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x004466 });
            const cubeEdges = new THREE.LineSegments(edges, lineMaterial);
            cube.add(cubeEdges);
            
            // Add cube to 3D scenes
            scenes.linear3D.add(cube.clone());
            scenes.hemi3D.add(cube.clone());
            
            // Create viewpoint sphere (shared)
            const viewpointGeometry = new THREE.SphereGeometry(0.2, 32, 32);
            const viewpointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            viewpointSphere = new THREE.Mesh(viewpointGeometry, viewpointMaterial);
            
            scenes.linear3D.add(viewpointSphere.clone());
            scenes.hemi3D.add(viewpointSphere.clone());
            
            // Create image plane for linear perspective (size will be updated dynamically)
            const planeSize = 2 * hemisphereRadius;
            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
            imagePlane = new THREE.Mesh(planeGeometry, planeMaterial);
            imagePlane.position.set(viewpointPosition.x, viewpointPosition.y, getImagePlaneZ()); // Center at viewpoint height
            
            const planeEdges = new THREE.EdgesGeometry(planeGeometry);
            const planeEdgesMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.5 });
            const planeBorder = new THREE.LineSegments(planeEdges, planeEdgesMaterial);
            imagePlane.add(planeBorder);
            scenes.linear3D.add(imagePlane);
            
            // Create hemisphere for hemispherical perspective
            const hemisphereGeometry = new THREE.SphereGeometry(hemisphereRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const hemisphereMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
            hemisphere = new THREE.Mesh(hemisphereGeometry, hemisphereMaterial);
            hemisphere.rotation.x = -Math.PI / 2;
            
            const hemisphereWireframe = new THREE.WireframeGeometry(hemisphereGeometry);
            const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.3, transparent: true });
            const hemisphereWire = new THREE.LineSegments(hemisphereWireframe, wireframeMaterial);
            hemisphere.add(hemisphereWire);
            scenes.hemi3D.add(hemisphere);
            
            // Add grid helpers
            const gridHelper1 = new THREE.GridHelper(20, 20, 0xcccccc, 0xdddddd);
            const gridHelper2 = new THREE.GridHelper(20, 20, 0xcccccc, 0xdddddd);
            gridHelper1.position.y = -5;
            gridHelper2.position.y = -5;
            scenes.linear3D.add(gridHelper1);
            scenes.hemi3D.add(gridHelper2);
            
            // Create 2D boundaries
            createLinear2DBoundary();
            createHemi2DBoundary();
            
            // Create viewpoint markers for 2D scenes
            const pvRingGeom = new THREE.RingGeometry(0.15, 0.2, 24);
            const pvRingMat1 = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const pvRingMat2 = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const projectedViewpointMarker1 = new THREE.Mesh(pvRingGeom, pvRingMat1);
            const projectedViewpointMarker2 = new THREE.Mesh(pvRingGeom, pvRingMat2);
            scenes.linear2D.add(projectedViewpointMarker1);
            scenes.hemi2D.add(projectedViewpointMarker2);
            
            updateProjections();
        }

        function createLinear2DBoundary() {
            const halfSize = hemisphereRadius; // Half of 2R size
            // Fixed boundary centered at origin (reference frame)
            const planeBoundaryPoints = [
                new THREE.Vector3(-halfSize, -halfSize, 0), 
                new THREE.Vector3(halfSize, -halfSize, 0),
                new THREE.Vector3(halfSize, halfSize, 0), 
                new THREE.Vector3(-halfSize, halfSize, 0)
            ];
            const planeBoundaryGeom = new THREE.BufferGeometry().setFromPoints(planeBoundaryPoints);
            const planeBoundaryMat = new THREE.LineBasicMaterial({ color: 0x6667ab });
            window.linearBoundary = new THREE.LineLoop(planeBoundaryGeom, planeBoundaryMat);
            scenes.linear2D.add(window.linearBoundary);
        }

        function createHemi2DBoundary() {
            const boundaryRadius = (Math.PI / 2) * hemisphereRadius;
            const circleGeometry = new THREE.RingGeometry(boundaryRadius - 0.05, boundaryRadius, 64);
            const circleMaterial = new THREE.MeshBasicMaterial({ color: 0x6667ab, side: THREE.DoubleSide });
            window.hemiBoundary = new THREE.Mesh(circleGeometry, circleMaterial);
            scenes.hemi2D.add(window.hemiBoundary);
        }

        function update2DCameras() {
            ['linear2D', 'hemi2D'].forEach(id => {
                const viewElement = document.getElementById(id);
                const aspect = viewElement.clientWidth / viewElement.clientHeight;
                const camera = cameras[id];
                camera.left = -zoomLevel2D * aspect / 2;
                camera.right = zoomLevel2D * aspect / 2;
                camera.top = zoomLevel2D / 2;
                camera.bottom = -zoomLevel2D / 2;
                camera.updateProjectionMatrix();
            });
        }

        // Linear perspective projection functions
        function updateLinearProjection() {
            // Update cube and viewpoint positions using helper functions
            updateCubeInScene('linear3D', cube);
            updateViewpointInScene('linear3D', viewpointPosition);
            
            // Update image plane size, position and center at viewpoint height
            const currentImagePlaneZ = getImagePlaneZ();
            const newPlaneSize = 2 * hemisphereRadius;
            
            // Update image plane geometry if size changed
            if (imagePlane.geometry.parameters.width !== newPlaneSize) {
                // Dispose old geometries
                imagePlane.geometry.dispose();
                const planeBorder = imagePlane.children[0];
                if (planeBorder && planeBorder.geometry) {
                    planeBorder.geometry.dispose();
                }
                
                // Create new geometries
                imagePlane.geometry = new THREE.PlaneGeometry(newPlaneSize, newPlaneSize);
                if (planeBorder) {
                    planeBorder.geometry = new THREE.EdgesGeometry(imagePlane.geometry);
                }
            }
            
            // Position image plane at viewpoint height and correct Z distance
            imagePlane.position.set(viewpointPosition.x, viewpointPosition.y, currentImagePlaneZ);
            
            // Update 2D boundary - fixed at origin in reference frame
            if (window.linearBoundary) {
                scenes.linear2D.remove(window.linearBoundary);
                safeDispose(window.linearBoundary);
            }
            const boundaryHalfSize = hemisphereRadius;
            // Fixed boundary centered at origin (viewpoint projection is always at origin)
            const planeBoundaryPoints = [
                new THREE.Vector3(-boundaryHalfSize, -boundaryHalfSize, 0), 
                new THREE.Vector3(boundaryHalfSize, -boundaryHalfSize, 0),
                new THREE.Vector3(boundaryHalfSize, boundaryHalfSize, 0), 
                new THREE.Vector3(-boundaryHalfSize, boundaryHalfSize, 0)
            ];
            const planeBoundaryGeom = new THREE.BufferGeometry().setFromPoints(planeBoundaryPoints);
            const planeBoundaryMat = new THREE.LineBasicMaterial({ color: 0x6667ab });
            window.linearBoundary = new THREE.LineLoop(planeBoundaryGeom, planeBoundaryMat);
            scenes.linear2D.add(window.linearBoundary);
            
            // Clear previous projections
            Object.values(groups.linear2D).forEach(group => clearGroup(group));
            Object.values(groups.linear3D).forEach(group => clearGroup(group));
            
            // Update projected viewpoint marker (always at origin in reference frame)
            updateProjectedViewpointMarker('linear2D', 0, 0);
            
            // Project cube vertices (use cached vertices for better performance)
            const worldVertices = getCachedWorldVertices();
            const projectedVertices = [];

            // Draw projection lines and calculate 2D projections
            worldVertices.forEach(worldVertex => {
                const lineMat = createMaterial('ProjectionLineMaterial');
                groups.linear3D.projectionLines.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([viewpointPosition, worldVertex]), lineMat));
                
                const x = worldVertex.x - viewpointPosition.x;
                const y = worldVertex.y - viewpointPosition.y;
                const z = worldVertex.z - viewpointPosition.z;

                if (z !== 0) {
                     const x_proj = x * (currentImagePlaneZ - viewpointPosition.z) / z + viewpointPosition.x;
                     const y_proj = y * (currentImagePlaneZ - viewpointPosition.z) / z + viewpointPosition.y;
                     // Transform to reference frame where viewpoint projection is at origin
                     const x_ref = x_proj - viewpointPosition.x;
                     const y_ref = y_proj - viewpointPosition.y;
                     projectedVertices.push(new THREE.Vector2(x_ref, y_ref));
                } else {
                     projectedVertices.push(new THREE.Vector2(Infinity, Infinity));
                }
            });

            // Draw projected cube edges
            const edges = [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ];
            const projectedLineMaterial = createMaterial('LineBasicMaterial');
            for (let i = 0; i < edges.length; i += 2) {
                const p1 = projectedVertices[edges[i]];
                const p2 = projectedVertices[edges[i+1]];
                if (isFinite(p1.x) && isFinite(p1.y) && isFinite(p2.x) && isFinite(p2.y)) {
                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(p1.x, p1.y, 0),
                        new THREE.Vector3(p2.x, p2.y, 0)
                    ]), projectedLineMaterial);
                    groups.linear2D.projectedCubeLines.add(line);
                }
            }

            // Calculate and draw vanishing points
            const dirX = new THREE.Vector3().subVectors(worldVertices[1], worldVertices[0]);
            const dirY = new THREE.Vector3().subVectors(worldVertices[3], worldVertices[0]);
            const dirZ = new THREE.Vector3().subVectors(worldVertices[4], worldVertices[0]);

            const vanishingPoints = [
                { dir: dirX, color: 0xff4136, lightColor: 0xffaaaa }, // Red
                { dir: dirY, color: 0x2ecc40, lightColor: 0xaaffaa }, // Green
                { dir: dirZ, color: 0x0074d9, lightColor: 0xaaaaff }  // Blue
            ].map(item => {
                let vp = new THREE.Vector2(Infinity, Infinity);
                const dz = item.dir.z;
                if (Math.abs(dz) > 0.0001) {
                    const t = (currentImagePlaneZ - viewpointPosition.z) / dz;
                    const vp_x = viewpointPosition.x + t * item.dir.x;
                    const vp_y = viewpointPosition.y + t * item.dir.y;
                    // Transform to reference frame where viewpoint projection is at origin
                    vp.x = vp_x - viewpointPosition.x;
                    vp.y = vp_y - viewpointPosition.y;
                }
                return { point: vp, color: item.color, lightColor: item.lightColor };
            });

            vanishingPoints.forEach(vpData => {
                if (isFinite(vpData.point.x) && isFinite(vpData.point.y)) {
                    const vpGeom = new THREE.CircleGeometry(0.15, 16);
                    const vpMat = createMaterial('VanishingPointMaterial', { color: vpData.color });
                    const vpMesh = new THREE.Mesh(vpGeom, vpMat);
                    vpMesh.position.set(vpData.point.x, vpData.point.y, 0);
                    groups.linear2D.vanishingPoints.add(vpMesh);
                }
            });

            // Draw guide lines from cube edges to vanishing points
            const edgeAxisMapping = {
                0: [0, 1,  2, 3,  4, 5,  6, 7], // X-axis edges (indices of vertices)
                1: [0, 3,  1, 2,  4, 7,  5, 6], // Y-axis edges
                2: [0, 4,  1, 5,  2, 6,  3, 7]  // Z-axis edges
            };

            vanishingPoints.forEach((vpData, axisIndex) => {
                if (!isFinite(vpData.point.x) || !isFinite(vpData.point.y)) return;

                const guideMaterial = createMaterial('GuideMaterial', { color: vpData.lightColor });

                const axisVertices = edgeAxisMapping[axisIndex];
                for (const vertexIndex of axisVertices) {
                    const p1 = projectedVertices[vertexIndex];
                    if (isFinite(p1.x) && isFinite(p1.y)) {
                        const lineGeom = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(p1.x, p1.y, 0),
                            new THREE.Vector3(vpData.point.x, vpData.point.y, 0)
                        ]);
                        const line = new THREE.Line(lineGeom, guideMaterial);
                        groups.linear2D.extensionLines.add(line);
                    }
                }
            });
        }

        // Hemispherical perspective helper functions
        function intersectRayWithHemisphere(rayOrigin, rayDirection) {
            const oc = rayOrigin.clone().sub(hemisphereCenter);
            const a = rayDirection.dot(rayDirection);
            const b = 2.0 * oc.dot(rayDirection);
            const c = oc.dot(oc) - hemisphereRadius * hemisphereRadius;
            
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) return null;
            
            const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
            const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);
            
            for (let t of [t1, t2]) {
                if (t > 0.001) {
                    const point = rayOrigin.clone().add(rayDirection.clone().multiplyScalar(t));
                    if (point.z <= hemisphereCenter.z) {
                        return point;
                    }
                }
            }
            return null;
        }

        function postelProjection(point3D) {
            const relativePoint = point3D.clone().sub(hemisphereCenter);
            const x = relativePoint.x;
            const y = relativePoint.y;
            const z = relativePoint.z;
            
            const cosAlpha = -z / hemisphereRadius;
            const alpha = Math.acos(Math.max(-1, Math.min(1, cosAlpha)));
            const arcLength = alpha * hemisphereRadius;
            const theta = Math.atan2(y, x);
            
            const x2D = arcLength * Math.cos(theta);
            const y2D = arcLength * Math.sin(theta);
            
            return new THREE.Vector2(x2D, y2D);
        }

        function createCircularArc(p1, p2, p3, material) {
            const ax = p1.x, ay = p1.y;
            const bx = p2.x, by = p2.y; 
            const cx = p3.x, cy = p3.y;
            
            const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
            if (Math.abs(d) < 0.0001) {
                return new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(p1.x, p1.y, 0),
                    new THREE.Vector3(p2.x, p2.y, 0)
                ]), material);
            }
            
            const ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d;
            const uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d;
            
            const centerX = ux;
            const centerY = uy;
            const radius = Math.sqrt((ax - centerX) * (ax - centerX) + (ay - centerY) * (ay - centerY));
            
            const angle1 = Math.atan2(p1.y - centerY, p1.x - centerX);
            const angle2 = Math.atan2(p2.y - centerY, p2.x - centerX);
            
            const segments = 32;
            const points = [];
            
            let startAngle = angle1;
            let endAngle = angle2;
            let angleDiff = endAngle - startAngle;
            if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            endAngle = startAngle + angleDiff;
            
            for (let i = 0; i <= segments; i++) {
                const angle = startAngle + (endAngle - startAngle) * i / segments;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                points.push(new THREE.Vector3(x, y, 0));
            }
            
            return new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), material);
        }

        function updateHemisphericalProjection() {
            // Update cube and viewpoint positions using helper functions
            updateCubeInScene('hemi3D', cube);
            updateViewpointInScene('hemi3D', viewpointPosition);
            
            // Update hemisphere
            hemisphereCenter.copy(viewpointPosition);
            hemisphere.position.copy(hemisphereCenter);
            // No scaling needed - geometry is already created with correct radius
            
            // Update hemisphere boundary in 2D
            if (window.hemiBoundary) {
                scenes.hemi2D.remove(window.hemiBoundary);
                safeDispose(window.hemiBoundary);
            }
            createHemi2DBoundary();
            
            // Clear previous projections
            Object.values(groups.hemi2D).forEach(group => clearGroup(group));
            Object.values(groups.hemi3D).forEach(group => clearGroup(group));
            
            // Update projected viewpoint marker
            const hemisphereDir = hemisphereCenter.clone().sub(viewpointPosition).normalize();
            const viewpointOnHemisphere = intersectRayWithHemisphere(viewpointPosition, hemisphereDir);
            if (viewpointOnHemisphere) {
                const projected2D = postelProjection(viewpointOnHemisphere);
                updateProjectedViewpointMarker('hemi2D', projected2D.x, projected2D.y);
            }
            
            // Project cube vertices (use cached vertices for better performance)
            const worldVertices = getCachedWorldVertices();
            const projectedVertices = [];

            // Draw projection lines and calculate hemisphere intersections
            worldVertices.forEach(worldVertex => {
                const rayDirection = worldVertex.clone().sub(viewpointPosition).normalize();
                
                const lineMat = createMaterial('ProjectionLineMaterial', { opacity: 0.3 });
                const extendedPoint = viewpointPosition.clone().add(rayDirection.clone().multiplyScalar(30));
                groups.hemi3D.projectionLines.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([viewpointPosition, extendedPoint]), lineMat));
                
                const hemisphereIntersection = intersectRayWithHemisphere(viewpointPosition, rayDirection);
                if (hemisphereIntersection) {
                    const hemisphereLineMat = createMaterial('ProjectionLineMaterial', { color: 0x00ff00, opacity: 0.6 });
                    groups.hemi3D.projectionLines.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([viewpointPosition, hemisphereIntersection]), hemisphereLineMat));
                    
                    const projected2D = postelProjection(hemisphereIntersection);
                    projectedVertices.push(projected2D);
                } else {
                    projectedVertices.push(new THREE.Vector2(Infinity, Infinity));
                }
            });

            // Calculate vanishing points
            const dirX = new THREE.Vector3().subVectors(worldVertices[1], worldVertices[0]);
            const dirY = new THREE.Vector3().subVectors(worldVertices[3], worldVertices[0]);
            const dirZ = new THREE.Vector3().subVectors(worldVertices[4], worldVertices[0]);

            const vanishingPointData = [
                { dir: dirX.normalize(), color: 0xff4136 },
                { dir: dirY.normalize(), color: 0x2ecc40 },
                { dir: dirZ.normalize(), color: 0x0074d9 }
            ];

            const vanishingPoints = [];
            vanishingPointData.forEach(vpData => {
                const directions = [vpData.dir, vpData.dir.clone().negate()];
                
                directions.forEach((direction, index) => {
                    const hemisphereIntersection = intersectRayWithHemisphere(viewpointPosition, direction);
                    
                    if (hemisphereIntersection) {
                        const projected2D = postelProjection(hemisphereIntersection);
                        
                        if (isFinite(projected2D.x) && isFinite(projected2D.y)) {
                            vanishingPoints.push(projected2D);
                            
                            const vpGeom = new THREE.CircleGeometry(0.15, 16);
                            const vpMat = new THREE.MeshBasicMaterial({ 
                                color: vpData.color,
                                opacity: index === 0 ? 1.0 : 0.7,
                                transparent: index === 1
                            });
                            const vpMesh = new THREE.Mesh(vpGeom, vpMat);
                            vpMesh.position.set(projected2D.x, projected2D.y, 0.1);
                            groups.hemi2D.vanishingPoints.add(vpMesh);
                        } else {
                            vanishingPoints.push(null);
                        }
                    } else {
                        vanishingPoints.push(null);
                    }
                });
            });

            // Helper functions for arc drawing
            function getVanishingPointForEdge(v1Index, v2Index) {
                const boundaryRadius = (Math.PI / 2) * hemisphereRadius;
                const edgeDirections = {
                    '0,1': 0, '1,0': 0, '1,2': 1, '2,1': 1, '2,3': 0, '3,2': 0, '3,0': 1, '0,3': 1,
                    '4,5': 0, '5,4': 0, '5,6': 1, '6,5': 1, '6,7': 0, '7,6': 0, '7,4': 1, '4,7': 1,
                    '0,4': 2, '4,0': 2, '1,5': 2, '5,1': 2, '2,6': 2, '6,2': 2, '3,7': 2, '7,3': 2
                };
                
                const key = `${v1Index},${v2Index}`;
                let axisIndex = edgeDirections[key];
                if (axisIndex === undefined) return { vp: null, axisIndex: null };
                
                const posVP = vanishingPoints[axisIndex * 2];
                const negVP = vanishingPoints[axisIndex * 2 + 1];
                
                if (posVP && (posVP.x * posVP.x + posVP.y * posVP.y) <= boundaryRadius * boundaryRadius) {
                    return { vp: posVP, axisIndex: axisIndex };
                }
                if (negVP && (negVP.x * negVP.x + negVP.y * negVP.y) <= boundaryRadius * boundaryRadius) {
                    return { vp: negVP, axisIndex: axisIndex };
                }
                
                return { vp: null, axisIndex: axisIndex };
            }

            function getLighterColor(axisIndex) {
                const colors = [0xffaaaa, 0xaaffaa, 0xaaaaff];
                return colors[axisIndex];
            }

            // Draw projected cube edges as circular arcs
            const edges = [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ];
            const projectedLineMaterial = new THREE.LineBasicMaterial({ color: 0x0077cc, linewidth: 2 });
            
            for (let i = 0; i < edges.length; i += 2) {
                const v1Index = edges[i];
                const v2Index = edges[i+1];
                const p1 = projectedVertices[v1Index];
                const p2 = projectedVertices[v2Index];
                
                if (p1 && p2 && isFinite(p1.x) && isFinite(p1.y) && isFinite(p2.x) && isFinite(p2.y)) {
                    const vpResult = getVanishingPointForEdge(v1Index, v2Index);
                    
                    if (vpResult.vp) {
                        const arc = createCircularArc(p1, p2, vpResult.vp, projectedLineMaterial);
                        groups.hemi2D.projectedCubeLines.add(arc);
                        
                        // Draw guide lines
                        const guideColor = getLighterColor(vpResult.axisIndex);
                        const guideMaterial = new THREE.LineBasicMaterial({ 
                            color: guideColor, 
                            opacity: 0.4, 
                            transparent: true,
                            linewidth: 1
                        });
                        
                        const guide1 = createCircularArc(p1, vpResult.vp, p2, guideMaterial);
                        const guide2 = createCircularArc(p2, vpResult.vp, p1, guideMaterial);
                        
                        groups.hemi2D.projectedCubeLines.add(guide1);
                        groups.hemi2D.projectedCubeLines.add(guide2);
                    } else {
                        const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(p1.x, p1.y, 0),
                            new THREE.Vector3(p2.x, p2.y, 0)
                        ]), projectedLineMaterial);
                        groups.hemi2D.projectedCubeLines.add(line);
                    }
                }
            }
        }

        function updateProjections() {
            // Simplified change detection - still use caching but be less aggressive
            const currentHash = generateUpdateHash();
            if (currentHash === lastUpdateHash) {
                return; // No changes, skip update
            }
            lastUpdateHash = currentHash;
            
            // Always update both projections when needed
            updateLinearProjection();
            updateHemisphericalProjection();
            
            needsUpdate.linear = false;
            needsUpdate.hemi = false;
        }

        function setupEventListeners() {
            // Mouse interaction variables
            let isDraggingCube = false;
            let isDraggingScene = false;
            let isZooming2D = false;
            let previousMousePosition = { x: 0, y: 0 };

            // Add mouse event listeners to 3D view elements (for cube and scene rotation)
            const view3DElements = [document.getElementById('linear3D'), document.getElementById('hemi3D')];
            
            view3DElements.forEach(viewElement => {
                viewElement.addEventListener('mousedown', (e) => {
                    // Prevent dragging if clicking on controls
                    if (e.target.closest('#controls')) return;
                    
                    if (e.button === 0) { // Left click - rotate cube
                        isDraggingCube = true;
                    } else if (e.button === 2) { // Right click - rotate scene
                        isDraggingScene = true;
                    }
                    
                    previousMousePosition.x = e.clientX;
                    previousMousePosition.y = e.clientY;
                    e.preventDefault(); // Prevent text selection
                });

                viewElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault(); // Prevent right-click context menu
                });
            });

            // Add mouse event listeners to 2D view elements (for zooming)
            const view2DElements = [document.getElementById('linear2D'), document.getElementById('hemi2D')];
            
            view2DElements.forEach(viewElement => {
                viewElement.addEventListener('mousedown', (e) => {
                    // Prevent zooming if clicking on controls
                    if (e.target.closest('#controls')) return;
                    
                    isZooming2D = true;
                    previousMousePosition.y = e.clientY;
                    e.preventDefault(); // Prevent text selection
                });

                // Add wheel event for zooming
                viewElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.5;
                    const delta = e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
                    
                    zoomLevel2D += delta;
                    zoomLevel2D = Math.max(5, Math.min(100, zoomLevel2D)); // Clamp zoom level
                    update2DCameras();
                    lastActivity = Date.now(); // Track wheel zoom activity
                    scheduleUpdate('zoom2D'); // Only 2D viewports need zoom updates
                });
            });

            // Global mouse move event (handles cube rotation, scene rotation, and 2D zoom)
            window.addEventListener('mousemove', (e) => {
                if (isDraggingCube) {
                    // Handle cube rotation (left click)
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    cube.rotateOnAxis(new THREE.Vector3(0, 1, 0), deltaX * 0.005);
                    cube.rotateOnAxis(new THREE.Vector3(1, 0, 0), deltaY * 0.005);
                    
                    cubeLocalRotation.y += deltaX * 0.005 * 180 / Math.PI;
                    cubeLocalRotation.x += deltaY * 0.005 * 180 / Math.PI;
                    
                    document.getElementById('cubeRotX').value = Math.round(cubeLocalRotation.x);
                    document.getElementById('cubeRotY').value = Math.round(cubeLocalRotation.y);
                    
                    scheduleUpdate('all', true); // Immediate update for mouse interaction
                    
                    previousMousePosition.x = e.clientX;
                    previousMousePosition.y = e.clientY;
                } else if (isDraggingScene) {
                    // Handle scene rotation (right click) - rotate cameras around origin
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    // Rotate both 3D cameras
                    ['linear3D', 'hemi3D'].forEach(id => {
                        const camera = cameras[id];
                        
                        // Horizontal rotation (around Y axis)
                        const yAxis = new THREE.Vector3(0, 1, 0);
                        const rotationY = new THREE.Matrix4().makeRotationAxis(yAxis, -deltaX * 0.005);
                        camera.position.applyMatrix4(rotationY);
                        
                        // Vertical rotation (around camera's local X axis)
                        const xAxis = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 0);
                        const rotationX = new THREE.Matrix4().makeRotationAxis(xAxis, -deltaY * 0.005);
                        camera.position.applyMatrix4(rotationX);
                        
                        // Keep camera looking at origin
                        camera.lookAt(0, 0, 0);
                    });
                    
                    lastActivity = Date.now(); // Track camera movement activity
                    scheduleUpdate('camera'); // Only 3D viewports need camera updates
                    previousMousePosition.x = e.clientX;
                    previousMousePosition.y = e.clientY;
                } else if (isZooming2D) {
                    // Handle 2D zoom
                    const deltaY = e.clientY - previousMousePosition.y;
                    const zoomSpeed = 0.1;
                    
                    zoomLevel2D += deltaY * zoomSpeed;
                    zoomLevel2D = Math.max(5, Math.min(100, zoomLevel2D)); // Clamp zoom level
                    update2DCameras();
                    lastActivity = Date.now(); // Track zoom activity
                    scheduleUpdate('zoom2D'); // Only 2D viewports need zoom updates
                    
                    previousMousePosition.y = e.clientY;
                }
            });

            window.addEventListener('mouseup', () => {
                isDraggingCube = false;
                isDraggingScene = false;
                isZooming2D = false;
            });

            // Prevent drag interaction when using controls
            document.getElementById('controls').addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Prevent event from bubbling up
            });

            // Slider controls (fixed setup)
            setupSliderControl('viewpointY', (value) => {
                viewpointPosition.y = value;
            });
            
            setupSliderControl('viewpointZ', (value) => {
                viewpointPosition.z = value;
            });
            
            setupSliderControl('hemisphereRadius', (value) => {
                hemisphereRadius = value;
                
                // Recreate hemisphere with new radius
                scenes.hemi3D.remove(hemisphere);
                safeDispose(hemisphere); // Dispose old hemisphere and its children
                
                const hemisphereGeometry = new THREE.SphereGeometry(hemisphereRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const hemisphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x0000ff, 
                    transparent: true, 
                    opacity: 0.15, 
                    side: THREE.DoubleSide 
                });
                hemisphere = new THREE.Mesh(hemisphereGeometry, hemisphereMaterial);
                hemisphere.position.copy(hemisphereCenter);
                hemisphere.rotation.x = -Math.PI / 2;
                
                const hemisphereWireframe = new THREE.WireframeGeometry(hemisphereGeometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.3, transparent: true });
                const hemisphereWire = new THREE.LineSegments(hemisphereWireframe, wireframeMaterial);
                hemisphere.add(hemisphereWire);
                
                scenes.hemi3D.add(hemisphere);
            });

            setupRotationControl('cubeRotX', 'x', cubeLocalRotation);
            setupRotationControl('cubeRotY', 'y', cubeLocalRotation);
            setupRotationControl('cubeRotZ', 'z', cubeLocalRotation);

            setupSliderControl('zoom3D', (value) => {
                const newDistance = value;
                ['linear3D', 'hemi3D'].forEach(id => {
                    const camera = cameras[id];
                    const currentDistance = camera.position.length();
                    if (currentDistance > 0) {
                        const scale = newDistance / currentDistance;
                        camera.position.multiplyScalar(scale);
                    }
                });
            });

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            Object.keys(renderers).forEach(id => {
                const viewElement = document.getElementById(id);
                const camera = cameras[id];
                const renderer = renderers[id];
                
                if (camera.isPerspectiveCamera) {
                    camera.aspect = viewElement.clientWidth / viewElement.clientHeight;
                    camera.updateProjectionMatrix();
                } else {
                    const aspect = viewElement.clientWidth / viewElement.clientHeight;
                    camera.left = -zoomLevel2D * aspect / 2;
                    camera.right = zoomLevel2D * aspect / 2;
                    camera.top = zoomLevel2D / 2;
                    camera.bottom = -zoomLevel2D / 2;
                    camera.updateProjectionMatrix();
                }
                
                renderer.setSize(viewElement.clientWidth, viewElement.clientHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const deltaTime = now - lastFrameTime;
            const timeSinceLastActivity = now - lastActivity;
            
            // Smart frame rate scaling
            isIdle = timeSinceLastActivity > 1000; // Consider idle after 1 second
            if (isIdle) {
                targetFPS = 30; // Reduce to 30fps when idle
                frameInterval = 1000 / targetFPS;
            }
            
            // Frame rate limiting
            if (deltaTime < frameInterval) {
                return; // Skip this frame
            }
            
            lastFrameTime = now;
            frameCount++;
            renderStats.totalFrames++;
            
            // Selective rendering: only render viewports that are dirty
            let rendered = false;
            const renderStartTime = performance.now();
            
            if (!isIdle || needsUpdate.render) {
                Object.keys(renderers).forEach(id => {
                    if (viewportDirty[id] || !isIdle) {
                        renderers[id].render(scenes[id], cameras[id]);
                        viewportDirty[id] = false;
                        rendered = true;
                    }
                });
                
                if (rendered) {
                    needsUpdate.render = false;
                }
            }
            
            // Update render stats
            if (rendered) {
                renderStats.renderTime = performance.now() - renderStartTime;
            } else {
                renderStats.skippedFrames++;
            }
            
            // Calculate FPS every second
            if (frameCount % 60 === 0) {
                const timeDiff = now - (renderStats.lastFPSTime || now);
                if (timeDiff > 0) {
                    renderStats.lastFPS = Math.round(60000 / timeDiff);
                }
                renderStats.lastFPSTime = now;
            }
        }

        // Initialize the application
        window.addEventListener('load', init);
    </script>
</body>
</html> 